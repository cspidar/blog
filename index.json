[{"content":"1. 관계         Node\n  Document\n  HTMLDocument\n     CharacterData\n  Text\n  Comment\n        Element\n  HTMLElement\n  HTMLHeadElement\n  HTMLLIElement\n        Attr\n      Element, Tag, Attribute, Property, Component \n      2. BOM (Browser Object Model) navigator, screen, location, frames, history, XMLHttpRequest …​\n 2.1. Windows 객체   Window 객체는 모든 객체가 소속된 객체이고, 전역객체이면서, 창이나 프레임을 의미\n  전역변수와 함수가 사실은 window 객체의 프로퍼티와 메소드\n  모든 객체는 사실 window의 자식\n   \u0026lt;script\u0026gt; windows.alert(\u0026#39;a\u0026#39;) alert(\u0026#39;a\u0026#39;) // = windows.alert(\u0026#39;a\u0026#39;) \u0026lt;/script\u0026gt;   2.1.1. Communication   alert: 경고창\n\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;alert\u0026#34; onclick=\u0026#34;alert(\u0026#39;hello world\u0026#39;);\u0026#34; /\u0026gt;     confirm: 확인창\n\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;confirm\u0026#34; onclick=\u0026#34;func_confirm()\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; function func_confirm(){ if(confirm(\u0026#39;ok?\u0026#39;)) { alert(\u0026#39;ok\u0026#39;) } else { alert(\u0026#39;cancel\u0026#39;) } } \u0026lt;/script\u0026gt;     prompt: 팝업 입력창\n\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;prompt\u0026#34; onclick=\u0026#34;func_prompt()\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; function func_prompt(){ if(prompt(\u0026#39;id?\u0026#39;) === \u0026#39;egoing\u0026#39;){ alert(\u0026#39;welcome\u0026#39;) } else { alert(\u0026#39;fail\u0026#39;) } } \u0026lt;/script\u0026gt;       2.1.2. Location 문서 주소 제공\n   URL\nconsole.log(location.protocol, location.host, location.port, location.pathname, location.search, location.hash)     reload\nlocation.reload();       2.1.3. Navigator 브라우저 정보 제공\n  2.1.4. 창 제어 새 창 열기: window.open\n     3. DOM (Document Object Model) document, tag, class, id, element, component, attribute, property …​\n 3.1. 제어 대상 찾기 인자로 전달된 tag, class, id 에 해당하는 객체들을 찾아서 그 리스트를 NodeList라는 유사 배열에 담아서 반환, 중첩하여 좁힐수 있음\n   document.getElementsByTagName(\u0026#39;string\u0026#39;): 태그로 찾기\n  document.getElementsByClassName(\u0026#39;string\u0026#39;): 클래스로 찾기\n  document.getElementsById(\u0026#39;string\u0026#39;): 아이디로 찾기\n  document.getElementById(\u0026#39;string\u0026#39;): 아이디로 1개 찾기\n  document.querySelectorAll(\u0026#39;string\u0026#39;): css 선택자로 찾기\n  document.querySelector(\u0026#39;string\u0026#39;): css 선택자로 1개 찾기\n   \u0026lt;div id = \u0026#39;iA\u0026#39; class = \u0026#39;cA\u0026#39;\u0026gt; \u0026lt;p id = \u0026#39;iB\u0026#39; class = \u0026#39;cB\u0026#39;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let getList = document.getElementsByTagName(\u0026#39;div\u0026#39;).getElementsByTagName(\u0026#39;p\u0026#39;); let getList = document.getElementsByClassName(\u0026#39;cA\u0026#39;).getElementsByClassName(\u0026#39;cB\u0026#39;); let getList = document.getElementsById(\u0026#39;iA\u0026#39;).getElementsById(\u0026#39;iB\u0026#39;); let getList = document.querySelectorAll(\u0026#39;div\u0026#39;).querySelectorAll(\u0026#39;.cB\u0026#39;); getList[0].style.color=\u0026#39;red\u0026#39; let getItem = document.getElementById(\u0026#39;iA\u0026#39;) // document.getElementById(\u0026#39;iA\u0026#39;) = iA, 중첩은 불가 (iA.iB... X) let getItem = document.querySelector(\u0026#39;div\u0026#39;).style.color=\u0026#39;red\u0026#39;; let getItem = document.querySelector(\u0026#39;.cA\u0026#39;).style.color=\u0026#39;red\u0026#39;; getItem.style.color=\u0026#39;red\u0026#39; \u0026lt;/script\u0026gt;    3.2. Element 객체 3.2.1. 식별   Element.tagName: 태그 이름 조회 가능. 변경 불가.\n  Element.id: 문서에서 id는 단 하나만 등장할 수 있는 식별자. id 조회, 변경 가능.\n  Element.className: 클래스는 여러개의 엘리먼트를 그룹핑할 때 사용. 조회, 변경, 추가 가능\n  Element.classList: 클래스 조회, 추가, 제거, 토글 (없으면 추가, 있으면 제거) 가능\n   \u0026lt;li id=\u0026#34;iA\u0026#34; class=\u0026#34;cA\u0026#34;\u0026gt;Text\u0026lt;/li\u0026gt; \u0026lt;script\u0026gt; console.log(iA.tagName); // li console.log(iA.id); iA.id = \u0026#39;iB\u0026#39;; console.log(iA.classList); // [\u0026#39;cA\u0026#39;, value: \u0026#39;cA\u0026#39;] iA.classList.add(\u0026#39;cB\u0026#39;); // 추가 iA.classList.remove(\u0026#39;cB\u0026#39;); // 제거 iA.classList.toggle(\u0026#39;cB\u0026#39;); // 토글 (추가 시 true, 제거 시 false 반환) \u0026lt;/script\u0026gt;    3.2.2. 조회   Element.getElementsByClassName(\u0026#39;string\u0026#39;)\n  Element.getElementsByTagName(\u0026#39;string\u0026#39;)\n  Element.querySelector(\u0026#39;string\u0026#39;)\n  Element.querySelectorAll(\u0026#39;string\u0026#39;)\n    3.2.3. Attribute Attribute는 HTML에서 태그명만으로는 부족한 부가적인 정보\n   Element.getAttribute(name)\n  Element.setAttribute(name, value)\n  Element.hasAttribute(name)\n  Element.removeAttribute(name)\n   \u0026lt;a id=\u0026#34;iA\u0026#34; href=\u0026#34;http://google.com\u0026#34;\u0026gt;Google\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; iA.getAttribute(\u0026#39;href\u0026#39;); // 조회, http://google.com iA.setAttribute(\u0026#39;title\u0026#39;, \u0026#39;Google\u0026#39;); // 설정, title=\u0026#34;Google\u0026#34; iA.removeAttribute(\u0026#39;title\u0026#39;, \u0026#39;Google\u0026#39;); // 삭제 iA.hasAttribute(\u0026#39;title\u0026#39;) // 확인, 있으면 true, 없으면 false 반환 \u0026lt;/script\u0026gt;   Example 1. Attribute vs. Property Attribute 방식인 setAttribute(\u0026#39;class\u0026#39;, \u0026#39;important\u0026#39;)와 Property 방식인 className = \u0026#39;important’는 같은 결과를 만든다.\n iA.setAttribute(\u0026#39;title\u0026#39;, \u0026#39;Google\u0026#39;) // Attribute iA.title = \u0026#39;Google\u0026#39; // Property   Property 방식은 좀 더 간편하고 속도도 빠르지만 자바스크립트의 이름 규칙 때문에 실제 html 속성의 이름과 다른 이름을 갖는 경우가 있다. Attribute 방식은 titleA 와 같은 임의의 형식을 추가할 수 있으나 Property 방식은 미리 정해진 형식만 추가할 수 있다.\n       Attribute Property     readonly\n readOnly\n   rowspan\n rowSpan\n   colspan\n colSpan\n   usemap\n userMap\n   frameborder\n frameBorder\n   for\n htmlFor\n   maxlength\n maxLength\n        3.3. Node 객체 모든 DOM 객체는 Node 객체를 상속 받는다.\n 3.3.1. 관계 노드간 연결 정보를 조회하여 문서를 프로그래밍적으로 탐색\n   Node.childNodes: 자식 노드들을 유사배열에 담아 리턴\n  Node.firstChild: 첫번째 자식 노드 (#text = 태그사이에 공백이나 줄바꿈이 있으면 공백이 자식엘리먼트로 잡힘)\nExample 2. #text 무시 API   firstElementChild\n  lastElementChild\n  nextElementSibling\n  previousElementSibling\n       Node.lastChild: 마지막 자식 노드\n  Node.nextSibling: 다음 형제 노드\n  Node.previousSibling: 이전 형제 노드\n  Node.contains():\n  Node.hasChildNodes():\n   iA.childNodes // [text, h1, text, div#toc.toc2, text] iA.firstChild // #text iA.lastChild // #text iA.nextSibling // #text iA.previousSibling // #text iA.firstChild.nextSibling // \u0026lt;h1\u0026gt;WebJS\u0026lt;/h1\u0026gt;    3.3.2. 식별 각 구성요소의 소속 카테고리 확인\n   Node.nodeType: 노드 타입을 고유의 숫자로 반환\n  Node.nodeName: 노드 태그를 string으로 반환\n   iA.nodeType // 1 iA.firstChild.nodeType // 3 iA.nodeName // \u0026#39;div\u0026#39;    3.3.3. 값 Node 객체의 값 확인\n   Node.nodeValue\n  Node.textContent\n    3.3.4. 자식관리 Node 객체의 자식 (Child) 추가 또는 제거\n   Node.appendChild(newElement): 노드의 마지막 자식으로 newElement 추가 후 추가한 newElement 반환\n  Node.insertBefore(newElement, refElement): newElement 를 refElement 앞에 추가 후 후 추가한 newElement 반환\n  Node.removeChild(targetElement): targetElement 를 제거 후 제거한 targetElement 반환\n  Node.replaceChild(newElement, oldElement): oldElement 를 newElement 로 교체 후 oldElement 를 반환\n   iA.appendChild(document.createElement(\u0026#39;div\u0026#39;)) iA.insertBefore(document.createElement(\u0026#39;div\u0026#39;), iB) iA.removeChild(iB) iA.replaceChild(document.createElement(\u0026#39;div\u0026#39;), iB)    3.3.5. 제어   Node.innerHTML: 문자열로 자식 노드를 변경 (=) 하거나 추가 (+=) 하고 변경된 자식 노드를 반환하거나, 자식 노드의 값 조회\n  Node.outerHTML: 문자열로 자신을 포함한 노드를 변경 (=) 하거나 추가 (+=) 하고 변경된 자신을 포함한 노드를 반환하거나, 자신을 포함한 노드의 값 조회\n  Node.innerText: innerHTML 노드 생성 방식은 같으나, html 코드를 제외한 문자열만 조회\n  Node.outerText: outerHTML 노드 생성 방식은 같으나, html 코드를 제외한 문자열만 조회\n   iA.innerHTML = \u0026#39;\u0026lt;div id = iB\u0026gt; B\u0026#39; // \u0026lt;div id=\u0026#34;iB\u0026#34;\u0026gt; B \u0026lt;/div\u0026gt; 미완성 문법 자동 보완 iA.innerHTML // \u0026lt;div id = iB\u0026gt; ... \u0026lt;/div\u0026gt; iA.outerHTML = \u0026#39;\u0026lt;div id = iB\u0026gt; B\u0026#39; iA.outerHTML // \u0026lt;div id = iA\u0026gt; ... \u0026lt;/div\u0026gt; iA.innerText // ... iA.outerText // ...     Node.insertAdjacentHTML(position: string, string): 특정 위치에 string 으로 작성된 노드를 추가\nposition   \u0026#39;beforebegin\u0026#39;: element 앞에\n  \u0026#39;afterbegin\u0026#39;: element 안에 가장 첫번째 child\n  \u0026#39;beforeend\u0026#39;: element 안에 가장 마지막 child\n  \u0026#39;afterend\u0026#39;: element 뒤에\n     \u0026lt;script\u0026gt; iA.insertAdjacentHTML(\u0026#39;beforebegin\u0026#39;, \u0026#39;\u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt;\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;!-- beforebegin --\u0026gt; \u0026lt;p\u0026gt; \u0026lt;!-- afterbegin --\u0026gt; foo \u0026lt;!-- beforeend --\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!-- afterend --\u0026gt;     Note  유사 API: insertAdjacentElement, insertAdjacentText            4. Document 객체 새로운 노드를 생성해주는 역할. 노드 변경 API와 동일. Node 객체 참조.\n   5. Text 객체 CharacterData를 상속. 텍스트 객체는 텍스트 노드에 대한 DOM 객체\n 5.1. 값 조회   CharacterData.data: 텍스트 노드의 텍스트 데이터를 반환\n  CharacterData.nodeValue: data와 같지만 속성 및 주석 노드 함께 반환\n  CharacterData.textContent: 해당 노드와 그 자손의 텍스트 데이터를 모두 반환\n  CharacterData.wholeText: ?\n   iA.firstChild.data iA.firstChild.nodeValue iA.firstChild.textContent iA.firstChild.wholeText    5.2. 값 제어   appendData(string): 텍스트 노드의 끝에 문자열 추가\n  deleteData(offset: number, count: number): offset (0 부터) 지점부터 count 갯수 (byte) 만큼 문자 삭제\n  insertData(offset: number, data: string): offset (0 부터) 지점에 data 추가\n  replaceData(offset: number, count: number, data: string): offset (0 부터) 지점부터 count 갯수 (byte) 만큼 문자를 삭제하고 data 추가\n  substringData(offset: number, count: number): offset (0 부터) 지점부터 count 갯수 (byte) 만큼 문자를 리턴\n      6. Event 이벤트 (event)는 변화가 생기는 사건을 의미. 브라우저에서의 사건이란 사용자가 클릭을 했을 \u0026#39;때\u0026#39;, 스크롤을 했을 \u0026#39;때\u0026#39;, 필드의 내용을 바꾸었을 \u0026#39;때’와 같은 것\n  Event target  이벤트가 일어날 객체\n  event.target: 부모 요소의 핸들러는 이벤트가 정확히 어디서 발생했는지 등에 대한 자세한 정보를 얻을 수 있음. 이벤트가 발생한 가장 안쪽의 요소는 타깃 (target) 요소라고 불리고, event.target을 사용해 접근 가능. 버블링이 진행되어도 변경되지 않음.\n  this ( = event.currentTarget): this는 ‘현재’ 요소로, 현재 실행 중인 핸들러가 현재 할당된 요소를 참조.\n      캡처링, 버블링과 관련된 내용은 전파 항목 확인\n  Event type  이벤트의 종류. 이미 정해져 있음.\n  전체 이벤트 목록: https://developer.mozilla.org/en-US/docs/Web/Events\n    Event handler  이벤트가 발생했을 때 동작하는 코드\n   6.1. 등록 방법  Inline  \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;target\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello world\u0026#39;);\u0026#34; value=\u0026#34;버튼\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello world\u0026#39;);\u0026#34; value=\u0026#34;버튼\u0026#34; /\u0026gt;    Property Listener  \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;iA\u0026#34; value=\u0026#34;again\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; iA.onclick = function(event){ alert(\u0026#39;Hello world, \u0026#39;+ event.target.value) } \u0026lt;/script\u0026gt;    addEventListener(event:string, eventHandler)  여러개의 이벤트 핸들러 등록 가능, eventType 의 이벤트 발생 시, eventHandler 실행\n\u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;iA\u0026#34; value=\u0026#34;버튼\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; iA.addEventListener(\u0026#39;click\u0026#39;, function(event){ alert(event.target.id)}); iA.addEventListener(\u0026#39;click\u0026#39;, function(event){ alert(event.target.value)}); \u0026lt;/script\u0026gt;       6.2. 전파   버블링 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작.\n  버블링 중단 이벤트 객체의 메서드인 event.stopPropagation()를 사용하여 핸들러에게 이벤트를 처리하고 난 후 버블링을 중단하도록 명령 가능.\n\u0026lt;body onclick=\u0026#34;alert(`버블링은 여기까지 도달하지 못합니다.`)\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;event.stopPropagation()\u0026#34;\u0026gt;클릭해 주세요.\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt;     Note  이벤트 버블링을 막아야 하는 경우는 거의 없습니다. 버블링을 막아야 해결되는 문제라면 커스텀 이벤트 등을 사용해 문제를 해결할 수 있습니다.          캡처링 이벤트가 최상위 조상에서 시작해 아래로 전파되고 (캡처링 단계), 이벤트가 타깃 요소에 도착해 실행된 후 (타깃 단계), 다시 위로 전파됩니다 (버블링 단계). 이런 과정을 통해 요소에 할당된 이벤트 핸들러를 호출 버블링과 캡처링은 \u0026#39;이벤트 위임 (event delegation)\u0026#39;의 토대가 됩니다. 이벤트 위임은 강력한 이벤트 핸들링 패턴입니다.\n  이벤트 위임 이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있습니다. 공통 조상에 할당한 핸들러에서 event.target을 이용하면 실제 어디서 이벤트가 발생했는지 알 수 있습니다. 이를 이용해 이벤트를 핸들링합니다. https://ko.javascript.info/event-delegation\n    6.3. 기본 동작의 취소 웹브라우저의 구성요소들의 정해진 기본적인 동작 방법 (기본 이벤트) 사용자가 만든 이벤트를 이용해서 취소\n   Inline: 이벤트 리턴값이 false 이면 기본 동작 취소 return false\n  property: 이벤트 리턴값이 false 이면 기본 동작 취소 return false\n  addEventListener(): 이벤트 객체의 preventDefault() 메소드를 실행하면 기본 동작 취소 event.preventDefault()\niA.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { dosomething(); event.preventDefault() } )       6.4. 이벤트 타입   submit: form의 정보를 서버로 전송하는 명령인 submit시에 일어나는 이벤트.\n\u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; iA.addEventListener(\u0026#39;submit\u0026#39;, e =\u0026gt; {...}) \u0026lt;/script\u0026gt;     change: 폼의 값이 변경 되었을 때 발생\n\u0026lt;input /\u0026gt; \u0026lt;script\u0026gt; iA.addEventListener(\u0026#39;change\u0026#39;, e =\u0026gt; {...}) \u0026lt;/script\u0026gt;     focus, blur: focus는 엘리먼트에 포커스가 생겼을 때, blur은 포커스가 사라졌을 때 발생\niA.addEventListener(\u0026#39;blur\u0026#39;, e =\u0026gt; {...}) iA.addEventListener(\u0026#39;focus\u0026#39;, e =\u0026gt; {...})     Note  blur, focus 발생 제외 태그: \u0026lt;base\u0026gt;, \u0026lt;bdo\u0026gt;, \u0026lt;br\u0026gt;, \u0026lt;head\u0026gt;, \u0026lt;html\u0026gt;, \u0026lt;iframe\u0026gt;, \u0026lt;meta\u0026gt;, \u0026lt;param\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;style\u0026gt;, \u0026lt;title\u0026gt;\n       DOMContentLoaded, load: DOMContentLoaded는 문서에서 스크립트 작업을 할 수 있을 때 실행, load는 문서내의 모든 리소스(이미지, 스크립트)의 다운로드가 끝난 후 실행\nwindow.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, e =\u0026gt; {...} )   window.addEventListener(\u0026#39;load\u0026#39;, e =\u0026gt; {...} )     마우스\n  click: 클릭했을 때 발생\n  dblclick: 더블클릭을 했을 때 발생\n  mousedown: 마우스를 누를 때 발생\n  mouseup: 마우스 버튼을 땔 때 발생\n  mousemove: 마우스를 움직일 때\n  mouseover: 마우스가 엘리먼트에 진입할 때 발생\n  mouseout: 마우스가 엘리먼트에서 빠져나갈 때 발생\n  contextmenu: 컨텍스트 메뉴 (팝업) 가 실행될 때 발생\n  event.clientX, event.clientY: 포인터 위치\n     키보드 조합: 특수키(alt, ctrl, shift)가 눌려진 상태를 감지\n  event.shiftKey\n  event.altKey\n  event.ctrlKey\n         7. 네트워크 통신 7.1. Ajax  7.2. JSON    8. html 추가 태그 종류 8.1. form 입력된 데이터를 서버로 전송. 태그는 전체 양식을 의미하며, 화면에 보이지 않는 추상적인 태그. input 태그 등으로 내부를 구성\n Attribute   name: 폼의 이름\n  action: 폼 데이터가 전송되는 백엔드 url\n  method: 폼 전송 방식 (GET / POST)\n  …\n   \u0026lt;form name=\u0026#34;testInputName\u0026#34; action=\u0026#34;xxxx.xxx.xxx\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;아이디\u0026lt;/strong\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; value=\u0026#34;아이디 입력\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;비밀번호\u0026lt;/strong\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; value=\u0026#34;비밀번호 입력\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;성별\u0026lt;/strong\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;M\u0026#34;\u0026gt;남자 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;F\u0026#34;\u0026gt;여자 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;응시분야\u0026lt;/strong\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;part\u0026#34; value=\u0026#34;eng\u0026#34;\u0026gt;영어 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;part\u0026#34; value=\u0026#34;math\u0026#34;\u0026gt;수학 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;제출\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt;    8.2. input 사용자 입력을 받음\n   type\n  text: 일반 문자\n  password: 비밀번호\n  button: 버튼\n  submit: 양식 제출용 버튼\n  reset: 양식 초기화용 버튼\n  radio: 한개만 선택할 수 있는 컴포넌트\n  checkbox: 다수를 선택할 수 있는 컴포넌트\n  file: 파일 업로드\n  hidden: 사용자에게 보이지 않는 숨은 요소\n       8.3. select, option 드롭 다운 리스트 생성\n \u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;ktx\u0026#34;\u0026gt;KTX\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;itx\u0026#34;\u0026gt;ITX 새마을\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;mugung\u0026#34;\u0026gt;무궁화호\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;      9. CSS 9.1. CSS Selector   Important  출처: https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize—​net-16048     9.1.1. * * { margin: 0; padding: 0; }   고급 선택자로 이동하기 전에 초보자를 위해 쉬운 선택자부터 알아보죠. 별표는 페이지에 있는 전체 요소를 대상으로 합니다. 많은 개발자가 margin과 padding 값을 0으로 세팅하려고 이 선택자를 사용합니다. 간단한 테스트 용도로서는 괜찮습니다. 그러나, 저는 여러분에게 이 별표를 실전에서 사용하지 말라고 권합니다. 브라우저에 과부하가 걸리고, 사용하기에 적절하지 않습니다.\n *를 자식 선택자에도 사용할 수 있습니다. #container * { border: 1px solid black; } 이 코드는 #container div의 자식 요소 전체를 대상으로 합니다. 한 번 더 말하지만, 이 선택자를 과다하게 사용하지 마세요.     9.1.2. #X #container { width: 960px; margin: auto; }   id 선택자. 선택자 앞에 해시(#) 기호를 붙여서 id를 대상으로 삼습니다. 가장 흔하고 쉽게 사용됩니다. 하지만, id 선택자를 사용할 때는 조심스러워야 합니다. 자문해 보세요. 이 요소를 대상으로 하기 위해 id를 필히 적용해야 할까요? id 선택자는 유연성이 없고 재활용할 수 없습니다. 가능한 처음에 태그 명이나 새로운 HTML 요소 중 하나, 아니면 가상 클래스라도 적어 보세요.\n  9.1.3. .X .error { color: red; }   class 선택자입니다. id와 class의 차이점이라면, 후자는 여러 개의 요소를 대상으로 정할 수 있습니다. 스타일을 한 그룹의 요소에 적용할 때는 class를 사용하세요. 찾을 가망성이 거의 없는 요소에 id를 사용하고 그 유일한 요소에만 스타일을 적용하세요.\n  9.1.4. X Y li a { text-decoration: none; }   다음으로 가장 많이 언급하는 선택자는 descendant (하위 선택자) 입니다. 선택자를 이용해 더 상세히 작업해야 할 때, 이 선택자를 사용합니다. 가령, 전체 앵커 태그를 대상으로 하기보다 순서를 매기지 않는 목록 (unordered list) 에 있는 앵커만 대상으로 한다면 어떨까요? 하위 선택자를 사용하면 상세해집니다.\n   Note  꿀팁 - 선택자가 X Y Z A B.error처럼 보이면 여러분은 작업을 잘못하고 있습니다. 모든 요소에 꼭 가중치를 둬야 하는지를 늘 자문하세요.      9.1.5. X a { color: red; } ul { margin-left: 0; }   만일 여러분이 id나 class가 아닌 type에 따라 한 페이지에 있는 모든 요소를 대상으로 삼고 싶다면 어떨까요? 간단히 type 선택자를 이용하세요. 순서가 정해지지 않은 목록 전부를 대상으로 해야 한다면 ul {}를 쓰세요.\n  9.1.6. X:visited 와 X:link a:link { color: red; } a:visted { color: purple; }   클릭하기 전 상태의 앵커 태그 전체를 대상으로 하려고 :link 가상 클래스를 사용합니다. :visited 가상 클래스로 하기도 합니다. 예상하듯이 이는 클릭했었거나 방문했던 페이지에 있는 앵커 태그에만 특정한 스타일을 적용할 수 있습니다.\n  9.1.7. X + Y ul + p { color: red; }   인접 선택자로 부르는 선택자입니다. 앞의 요소 바로 뒤에 있는 요소만 선택합니다. 위 코드에서 각 ul 뒤에 오는 첫 번째 단락의 텍스트만 빨간색이 됩니다.\n  9.1.8. X \u0026gt; Y div#container \u0026gt; ul { border: 1px solid black; }   일반 X Y와 X \u0026gt; Y의 차이점은 후자가 직계 자식만을 선택한다는 것입니다. 가령, 아래 마크업을 생각해 보세요.\n \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; // selected \u0026lt;li\u0026gt; List Item \u0026lt;ul\u0026gt; // not selected \u0026lt;li\u0026gt; Child \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; List Item \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt;   #container \u0026gt; ul 선택자는 id가 container인 div의 직계 첫번째 자손인 ul만 대상으로 삼습니다. 예를 들어 첫 번째 li의 자식인 ul은 대상이 되지 않습니다. 이런 이유로 자식 선택자를 이용해 성능을 향상할 수 있습니다. 사실, 자바스크립트를 기반으로 하는 CSS 선택자 엔진으로 작업할 때 추천합니다.\n  9.1.9. X ~ Y ul ~ p { color: red; }   이 형제 선택자는 X + Y와 유사하지만 덜 엄격합니다. 인접 선택자(ul + p)는 앞의 선택자 바로 뒤에 오는 첫 번째 요소만을 선택하지만, 이 선택자는 좀 더 관대합니다. 위의 예를 보면, ul 아래 있는 모든 p 요소를 선택할 것입니다.\n  9.1.10. X[title] a[title] { color: green; }   속성 선택자(attributes selector)라고 말하며, 앞의 예에서 title 속성이 있는 앵커 태그만을 선택합니다. title이 없는 앵커 태그에는 특정한 스타일이 적용되지 않습니다. 그런데 더 상세히 작업해야 한다면 어떨까요? 음…​\n  9.1.11. X[href=\u0026#34;foo\u0026#34;] a[href=\u0026#34;https://net.tutsplus.com\u0026#34;] { color: #1f6053; /* nettuts green */ }   위의 코드는 https://net.tutsplus.com 로 연결된 전체 앵커 태그에 스타일을 적용할 것입니다. 우리 브랜드 컬러인 녹색이 적용되겠지요. 그 외의 앵커 태그는 스타일의 영향을 받지 않습니다. 값을 큰따옴표로 감쌌음을 기억하세요. 자바스크립트 CSS 선택자 엔진을 사용할 때 활용하는 것도 잊지 마세요. 가능하면, 비공식적인 선택자보다 CSS3 선택자를 항상 사용하세요. 동작은 잘하겠지만, 융통성은 낮습니다. 만약 링크가 Nettuts+로 직접 이어지지만, 경로를 전체 url이 아닌 nettuts.com으로 한다면 어떨까요? 그 경우에 우리는 정규식 표현 문장을 약간 사용할 수 있습니다.\n  9.1.12. X[href*=\u0026#34;nettuts\u0026#34;] a[href*=\u0026#34;tuts\u0026#34;] { color: #1f6053; /* nettuts green */ }   야아. 우리에게 필요한 선택자네요. 별표는 입력값이 속성값 안 어딘가에 보여야 한다는 것을 표시합니다. 그렇게 이 구문은 nettuts.com, net.tutsplus.com 그리고 tutsplus.com까지도 적용하고 있습니다. 폭넓은 표현이라는 것을 알아 두세요. 만약 앵커 태그의 url에 tuts 문자열이 일부 Evato가 아닌 사이트로 연결되어 있다면 어떨까요? 더 자세히 작성해야 한다면, 문자열의 앞과 뒤에 ^와 $를 붙이세요.\n  9.1.13. X[href^=\u0026#34;http\u0026#34;] a[href^=\u0026#34;http\u0026#34;] { background: url(path/to/external/icon.png) no-repeat; padding-left: 10px; }   웹사이트에서 외부로 연결된 링크 옆에 작은 아이콘을 어떻게 보이게 했는지 궁금해한 적이 있나요? 틀림없이 전에 본 적이 있을 것입니다. 링크를 클릭하면 전혀 다른 웹사이트로 이동하리라는 것을 알게 해주니까요.\n 캐럿 기호를 이용하는 쉬운 작업입니다. 문자열의 시작을 표기하는 정규 표현식에서 흔히 사용됩니다. 만약 http로 시작하는 href 값을 가진 앵커 태그를 대상으로 하고 싶다면, 위의 코드와 유사한 선택자를 사용하면 됩니다.\n https://로는 찾아지지 않습니다. 이 표현은 부적절하고 https://로 시작하는 url도 마찬가지입니다.\n 여러분이 사진으로 링크 걸린 앵커 전체에 스타일을 적용하고 싶다면 어떨까요? 그 경우에는 문자열의 끝을 찾아봅시다.\n  9.1.14. X[href$=\u0026#34;.jpg\u0026#34;] a[href$=\u0026#34;.jpg\u0026#34;] { color: red; }   문자열 끝에 적용하도록 정규 표현식 기호인 $를 한번 더 사용하겠습니다. 이번 경우에는 이미지(나 최소한 .jpg로 끝나는 url)로 링크가 걸린 앵커 전체를 찾을 것입니다. gif와 png는 영향받지 않습니다.\n  9.1.15. X[data-*=\u0026#34;foo\u0026#34;] a[data-filetype=\u0026#34;image\u0026#34;] { color: red; }   8번 내용을 다시 참조합시다. 여러 가지 이미지 형식(png, jpeg, jpg, gif)은 어떻게 적용할 수 있을까요? 다음과 같이 우리는 선택자를 여러 개 만들 수 있습니다.\n a[href$=\u0026#34;.jpg\u0026#34;], a[href$=\u0026#34;.jpeg\u0026#34;], a[href$=\u0026#34;.png\u0026#34;], a[href$=\u0026#34;.gif\u0026#34;] { color: red; }   그런데, 이 방식은 골치 아프고 비효율적입니다. 커스텀 속성을 사용하는 다른 해결 방식이 있습니다. 이미지로 링크 걸린 앵커마다 data-filetype 속성을 넣으면 어떨까요?\n \u0026lt;a href=\u0026#34;path/to/image.jpg\u0026#34; data-filetype=\u0026#34;image\u0026#34;\u0026gt; Image Link \u0026lt;/a\u0026gt;   그러면 갈고리(hook) 역할을 이용해 해당 앵커만 대상으로 삼는 일반 속성 선택자를 사용할 수 있습니다.\n a[data-filetype=\u0026#34;image\u0026#34;] { color: red; }    9.1.16. X[foo~=\u0026#34;bar\u0026#34;] a[data-info~=\u0026#34;external\u0026#34;] { color: red; } a[data-info~=\u0026#34;image\u0026#34;] { border: 1px solid black; }   친구에게 깊은 인상을 남겨줄 특별한 선택자가 있습니다. 이 요령을 알고 있는 사람은 그리 많지 않습니다. 물결표(~)를 이용하면 띄어쓰기로 구분되는 값이 있는 속성을 대상으로 할 수 있습니다.\n 15번에 있는 커스텀 속성 방식으로 data-info 속성을 만들면 됩니다. 이 속성은 우리가 메모하는 무엇이든지 띄어쓰기로 구분한 목록을 받을 수 있습니다. 이 경우, 외부 링크와 이미지 링크를 메모할 수 있습니다. 단지 예를 들면 말이죠.\n \u0026#34;\u0026lt;a href=\u0026#34;path/to/image.jpg\u0026#34; data-info=\u0026#34;external image\u0026#34;\u0026gt; Click Me, Fool \u0026lt;/a\u0026gt;   위의 마크업을 적당한 위치에 쓰면 ~ 속성 선택자 방식을 이용해 두 개의 값 중 하나라도 있는 태그를 대상으로 삼을 수 있습니다.\n /* Target data-info attr that contains the value \u0026#34;external\u0026#34; */ a[data-info~=\u0026#34;external\u0026#34;] { color: red; } /* And which contain the value \u0026#34;image\u0026#34; */ a[data-info~=\u0026#34;image\u0026#34;] { border: 1px solid black; }     9.2. (*) 가상 클래스 (Pseudo class)   Note  https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes     CSS pseudo-class 는 선택될 요소(element)의 특별한 상태를 지정하는 선택자(selector)에 추가된 키워드입니다. 예를 들어 :hover는 사용자가 선택자에 의해 지정된 요소 위를 맴돌(hover) 때 스타일을 적용합니다.\n 가상 클래스(pseudo-class)는, 가상 요소(pseudo-elements)와 함께, 문서 트리의 콘텐츠 뿐만 아니라, 탐색기 히스토리 (가령, :visited), 콘텐츠 상태(일부 폼 요소의 :checked 같은) 혹은 마우스 위치 (마우스가 요소 위인지 알 수 있는 :hover 같이)처럼 외부 요인(factor) 관련 요소에 스타일을 적용할 수 있습니다\n   Note  규칙을 따라 단일 콜론(:) 대신 이중 콜론(::)을 사용하여 의사 클래스와 의사 요소를 구별해야 합니다. 그러나 과거 W3C 명세에선 이런 구별을 두지 않았으므로 대부분의 브라우저는 기존 의사 요소에 대해 두 구문 모두 지원합니다.       Note  가상선택자 적용이 안되는 경우 폼(form, input…​) 태그와 이미지 태그(img)는 가상선택자가 적용되지 않는다.     :active :checked :default :defined :disabled :drop :empty (en-US) :enabled :first :first-child :first-of-type :focus :focus-within :host (en-US) :host() (en-US) :hover :indeterminate (en-US) :in-range (en-US) :invalid (en-US) :lang() (en-US) :last-child (en-US) :last-of-type (en-US) :left (en-US) :link :not() :nth-child() :nth-last-child() (en-US) :nth-last-of-type() (en-US) :nth-of-type() (en-US) :only-child (en-US) :only-of-type (en-US) :optional (en-US) :out-of-range (en-US) :read-only (en-US) :read-write (en-US) :required (en-US) :right (en-US) :root :scope (en-US) :target (en-US) :valid (en-US) :visited\n Linguistic pseudo-classes These pseudo-classes reflect the document language, and enable the selection of elements based on language or script direction.\n :dir The directionality pseudo-class selects an element based on its directionality as determined by the document language.\n :lang Select an element based on its content language.\n Location pseudo-classes These pseudo-classes relate to links, and to targeted elements within the current document.\n :any-link Matches an element if the element would match either :link or :visited.\n :link Matches links that have not yet been visited.\n :visited Matches links that have been visited.\n :local-link Matches links whose absolute URL is the same as the target URL, for example anchor links to the same page.\n :target Matches the element which is the target of the document URL.\n :target-within Matches elements which are the target of the document URL, but also elements which have a descendant which is the target of the document URL.\n :scope Represents elements that are a reference point for selectors to match against.\n User action pseudo-classes These pseudo-classes require some interaction by the user in order for them to apply, such as holding a mouse pointer over an element.\n :hover Matches when a user designates an item with a pointing device, for example holding the mouse pointer over it.\n :active Matches when an item is being activated by the user, for example clicked on.\n :focus Matches when an element has focus.\n :focus-visible Matches when an element has focus and the user agent identifies that the element should be visibly focused.\n :focus-within Matches an element to which :focus applies, plus any element that has a descendant to which :focus applies.\n Time-dimensional pseudo-classes These pseudo-classes apply when viewing something which has timing, such as a WebVTT caption track.\n :current Represents the element or ancestor of the element that is being displayed.\n :past Represents an element that occurs entirely before the :current element.\n :future Represents an element that occurs entirely after the :current element.\n Resource state pseudo-classes These pseudo-classes apply to media that is capable of being in a state where it would be described as playing, such as a video.\n :playing Represents a media element that is capable of playing when that element is playing.\n :paused Represents a media element that is capable of playing when that element is paused.\n The input pseudo-classes These pseudo-classes relate to form elements, and enable selecting elements based on HTML attributes and the state that the field is in before and after interaction.\n :autofill Matches when an \u0026lt;input\u0026gt; has been autofilled by the browser.\n :enabled Represents a user interface element that is in an enabled state.\n :disabled Represents a user interface element that is in a disabled state.\n :read-only Represents any element that cannot be changed by the user.\n :read-write Represents any element that is user-editable.\n :placeholder-shown Matches an input element that is displaying placeholder text, for example from the HTML5 placeholder attribute.\n :default Matches one or more UI elements that are the default among a set of elements.\n :checked Matches when elements such as checkboxes and radiobuttons are toggled on.\n :indeterminate Matches when UI elements are in an indeterminate state.\n :blank Matches a user-input element which is empty, containing an empty string or other null input.\n :valid Matches an element with valid contents. For example an input element with type \u0026#39;email\u0026#39; which contains a validly formed email address.\n :invalid Matches an element with invalid contents. For example an input element with type \u0026#39;email\u0026#39; with a name entered.\n :in-range Applies to elements with range limitations, for example a slider control, when the selected value is in the allowed range.\n :out-of-range Applies to elements with range limitations, for example a slider control, when the selected value is outside the allowed range.\n :required Matches when a form element is required.\n :optional Matches when a form element is optional.\n :user-invalid Represents an element with incorrect input, but only when the user has interacted with it.\n Tree-structural pseudo-classes These pseudo-classes relate to the location of an element within the document tree.\n :root Represents an element that is the root of the document. In HTML this is usually the \u0026lt;html\u0026gt; element.\n :empty Represents an element with no children other than white-space characters.\n :nth-child Uses An+B notation to select elements from a list of sibling elements.\n :nth-last-child Uses An+B notation to select elements from a list of sibling elements, counting backwards from the end of the list.\n :first-child Matches an element that is the first of its siblings.\n :last-child Matches an element that is the last of its siblings.\n :only-child Matches an element that has no siblings. For example a list item with no other list items in that list.\n :nth-of-type Uses An+B notation to select elements from a list of sibling elements that match a certain type from a list of sibling elements.\n :nth-last-of-type Uses An+B notation to select elements from a list of sibling elements that match a certain type from a list of sibling elements counting backwards from the end of the list.\n :first-of-type Matches an element that is the first of its siblings, and also matches a certain type selector.\n :last-of-type Matches an element that is the last of its siblings, and also matches a certain type selector.\n :only-of-type Matches an element that has no siblings of the chosen type selector.\n 9.2.1. X:checked input[type=radio]:checked { border: 1px solid black; }   이 가상 클래스는 라디오 버튼이나 체크박스처럼 체크되는 사용자 인터페이스 요소만을 대상으로 합니다. 아래 코드처럼 간단합니다.\n  9.2.2. X:after before과 after 가상 클래스는 매우 효과적입니다. 사람들이 늘 이 두 클래스를 효과적으로 사용하는 새롭고 창의적인 방법을 찾고 있는 듯합니다. 이 클래스는 선택된 요소 주변에 콘텐츠를 생성합니다.\n 많은 사람이 clear-fix 핵을 접했을 때 이 클래스를 맨 먼저 도입했었습니다.\n .clearfix:after { content: \u0026#34;\u0026#34;; display: block; clear: both; visibility: hidden; font-size: 0; height: 0; } .clearfix { *display: inline-block; _height: 1%; }   Example 3. clearfix 핵 float 으로 인하여 영역이 깨지는 현상을 방지하기 위해 .clearfix 로 영역을 잡아준다.\n   이 핵은 요소 뒤에 공간을 덧붙이고 float 효과를 제거하는데 :after 가상 클래스를 사용했습니다. 특히 overflow: hidden; 방법이 불가능한 경우 여러분이 사용할 방법 중에 가장 훌륭한 방법입니다.\n 다른 창의적 방식은 그림자 제작에 관한 간단한 팁을 참조해 보세요.\n CSS3 선택자 명세서를 보면, 가상 요소는 엄밀히 말해 두 개의 콜론(::)으로 표현되어야 합니다. 그렇지만, 일관성을 위해 유저 에이전트는 콜론을 하나 사용한 경우도 허용합니다. 사실 현재, 프로젝트에서 콜론이 한 개인 버전을 사용하는 게 더 현명합니다.\n  9.2.3. X:hover div:hover { background: #e3e3e3; }   에이. 이 선택자는 알고 있겠죠. 공식 용어는 사용자 동작(user action) 가상 클래스랍니다. 혼란스럽겠지만 그렇지는 않습니다. 사용자가 요소 위에 커서를 올릴 때 특정한 스타일을 적용하고 싶나요? 이 선택자로 처리하세요!\n 알아두세요. 앵커 태그가 아닌 태그에 :hover 가상 클래스를 적용했을 때 인터넷 익스플로러의 하위 버전에서는 반응하지 않습니다.\n 대부분 hover 상태에서, 가령 앵커 태그에 border-bottom을 적용할 때 이 선택자를 사용합니다.\n a:hover { border-bottom: 1px solid black; }   꿀팁 - border-bottom: 1px solid black; 이 text-decoration: underline;보다 보기 더 좋습니다.\n  9.2.4. X:not(선택자) div:not(#container) { color: blue; }   negation 가상 클래스는 특히 유용합니다. 제가 모든 div를 선택하고 싶은데, 그중에서 id가 container인 것만 빼고 싶다고 합시다. 위의 코드가 그 작업을 완벽하게 수행합니다.\n 혹은, (권장하지 않지만) 제가 단락 태그만 제외하고 요소 전체를 선택하고 싶다고 한다면 아래처럼 하면 됩니다.\n *:not(p) { color: green; }    9.2.5. X:nth-child(n) li:nth-child(3) { color: red; }   여러 요소 중에서 특정 요소를 지목하는 방법이 없었던 시절이 기억나나요? 그 문제를 풀어줄 nth-child 가상 클래스가 있답니다!\n nth-child는 변숫값을 정수(integer)로 받습니다. 0부터 시작하지는 않습니다. 두 번째 항목을 대상으로 하고 싶다면 li:nth-child(2)로 작성합니다.\n 자식 요소의 변수 집합을 선택하는 데에도 이 방식을 활용할 수 있습니다. 가령, 항목의 4번째마다 선택하려면 li:nth-child(4n)로 작성하면 됩니다.\n  9.2.6. X:nth-last-child(n) li:nth-last-child(2) { color: red; }   만약 ul에 항목이 엄청 많고, 여러분은 끝에서 세 번째 항목만 필요하다고 한다면 어떨까요? li:nth-child(397)로 작성하지 말고 nth-last-child 가상 클래스를 쓰면 됩니다.\n 이 선택자는 16번과 거의 동일합니다. 다만 집합의 끝에서부터 출발하면서 동작한다는 게 다릅니다.\n  9.2.7. X:nth-of-type(n) ul:nth-of-type(3) { border: 1px solid black; }   child를 선택하지 않고 요소의 type을 선택해야 하는 날이 있을 것입니다.\n 순서를 정하지 않은 목록 5개가 있는 마크업을 상상해 보세요. 세 번째 ul에만 스타일을 지정하고 싶은데 그것을 지정할 유일한 id가 없다면, nth-of-type(n) 가상 클래스를 이용할 수 있습니다. 위의 코드에서 세 번째 ul에만 테두리 선이 둘려집니다.\n  9.2.8. X:nth-last-of-type(n) ul:nth-last-of-type(3) { border: 1px solid black; }   일관성을 유지하도록 목록 선택자의 끝부터 출발해 지정한 요소를 대상으로 하는 nth-last-of-type을 사용할 수도 있습니다.\n  9.2.9. X:first-child ul li:first-child { border-top: none; }\n 이 구조적 가상 클래스를 이용해 부모 요소의 첫 번째 자식만 대상으로 삼을 수 있습니다. 목록에서 맨 처음과 맨 나중 항목에서 테두리 선을 제거하는데 이 방식을 흔히 사용합니다.\n 예를 들면, 가로 행 목록이 있다고 합시다. 행마다 border-top과 border-bottom이 적용되어 있습니다. 글쎄요. 그 정렬에서 맨 처음과 마지막 항목이 약간 어색해 보이겠네요.\n 많은 디자이너가 이를 보완하려고 first와 last 클래스를 적용합니다. 그 대신에 여러분은 이 가상 클래스를 사용하면 됩니다.\n  9.2.10. X:last-child ul \u0026gt; li:last-child { color: green; }   first-child와 반대로 last-child는 부모 요소의 마지막 항목을 대상으로 합니다.\n 예제 이 클래스 중에 활용 가능한 사례를 보여주는 간단한 예제를 만들어 봅시다. 스타일이 적용된 항목을 제작하겠습니다.\n \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; List Item \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; List Item \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; List Item \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   그냥 코드입니다. 단순한 목록일 뿐이지요.\n ul { width: 200px; background: #292929; color: white; list-style: none; padding-left: 0; } li { padding: 10px; border-bottom: 1px solid black; border-top: 1px solid #3c3c3c; }   이 스타일에 배경을 입히고, 브라우저상에서 ul 기본값을 제거하며, 깊이를 약간 주려고 li 마다 테두리 선을 주겠습니다.\n Styled List 목록에 깊이를 더하기 위해 각각의 li 에 border-bottom을 적용합니다. 이는 그림자가 되거나 li 배경보다 어두운색이 될 것입니다. 다음에 배경보다 더 밝은 값을 border-top에 적용합니다.\n 단 한 가지 문제점은, 위의 이미지에서 보이듯, 순서에 정해지지 않은 목록의 맨 위와 맨 아래에도 테두리 선이 적용된다는 것입니다. 자연스럽게 보이지 않죠. :first-child와 :last-child 가상 클래스를 사용해 이 문제를 고쳐봅시다.\n li:first-child { border-top: none; } li:last-child { border-bottom: none; }   Fixed 야아. 고쳐졌군요!\n  9.2.11. X:only-child div p:only-child { color: red; }   솔직히 여러분은 아마 only-child 가상 클래스를 거의 사용하지 않을 것입니다. 그렇더라도 쓸 수 있으니 써봐야 하겠죠.\n 이 선택자는 부모의 단 하나의 자식 요소를 지정할 수 있습니다. 위의 코드를 참조하면, 가령, div의 단 하나의 자식인 문단만 빨간색으로 칠해질 것입니다.\n 아래의 마크업을 생각해 봅시다.\n \u0026lt;div\u0026gt;\u0026lt;p\u0026gt; My paragraph here. \u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; Two paragraphs total. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Two paragraphs total. \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   이 경우, 두 번째 div의 문단은 대상이 되지 않고 오직 첫 번째 div가 대상이 됩니다. 하나 이상의 자식을 요소에 적용하는 순간에 only-child 가상 클래스의 효과는 사라지게 됩니다.\n  9.2.12. X:only-of-type li:only-of-type { font-weight: bold; }   이 구조상의 가상 클래스는 기발한 방식으로 사용될 수 있습니다. 부모 컨테이너에 형제 요소가 없는 요소를 대상으로 합니다. 예로, 단 하나의 목록 아이템인 ul 전부를 대상으로 삼습니다.\n 우선, 이 작업을 어떻게 완료할지 자신에게 질문해 보세요. 여러분은 ul li로 하겠지만, 목록 아이템 전체가 대상이 됩니다. 유일한 해결 방법은 only-of-type을 사용하는 것입니다.\n ul \u0026gt; li:only-of-type { font-weight: bold; }    9.2.13. X:first-of-type first-of-type 가상 클래스로 해당 type의 첫 번째 형제 선택자를 선택할 수 있습니다.\n 이해를 돕도록 테스트를 해봅시다. 아래 마크업을 코드 편집기에 복사해 넣으세요.\n \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; My paragraph here. \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; List Item 1 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; List Item 2 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;    \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; List Item 3 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; List Item 4 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt;   다음 내용을 읽기 전에 \u0026#34;List Item 2\u0026#34;만 대상으로 하는 방법을 생각해 보세요. 생각났다면 (혹은 포기했더라도) 다음으로 넘어갑니다.\n   해결 방법 1 이 테스트를 푸는 방법은 여러 가지입니다. 이 중에서 몇 가지를 살펴보겠습니다. first-of-type을 사용해서 시작해 보지요.\nul:first-of-type \u0026gt; li:nth-child(2) { font-weight: bold; }   이 코드는 기본적으로 \u0026#34;페이지에서 순서를 중요시하지 않는 첫 번째 목록을 찾고 나서 목록 아이템인 직계 자식만 찾아라.\u0026#34;라고 이야기합니다. 그다음, 그 결과 세트에서 두 번째 목록 아이템만 걸러냅니다.\n   해결 방법 2 다른 방법은 인접 선택자를 사용하는 것입니다.\np + ul li:last-child { font-weight: bold; }   이 시나리오에서는 p 태그 바로 뒤에 있는 ul을 찾고 나서 그 요소의 가장 마지막 자식을 찾습니다.\n   해결 방법 3 이 선택자를 써서 원하는 대로 불쾌해하거나 쾌활해 할 수 있습니다.\nul:first-of-type li:nth-last-child(1) { font-weight: bold; }   이번에는 페이지에 있는 첫 번째 ul을 잡고 나서 가장 첫 번째 목록 아이템을 찾습니다. 바로 아래부터 시작해서요! :)\n      9.3. (*) 가상 요소 (Pseudo elements)   Note  https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements     :after :before :cue :cue-region :first-letter :first-line :selection :slotted()\n 9.3.1. X::가상 요소 p::first-line { font-weight: bold; font-size: 1.2em; }   첫 번째 줄이나 첫 글자와 같이 요소 일부분에 스타일을 적용하는데 가상 요소(::로 표기되는)를 사용할 수 있습니다. 효과를 보려면 이 요소를 반드시 블록 레벨 요소에 적용해야 합니다.\n 가상 요소는 두 개의 콜론(::)으로 표시됩니다.\n 단락의 첫 글자 p::first-letter { float: left; font-size: 2em; font-weight: bold; font-family: cursive; padding-right: 2px; }   이 코드는 페이지에 있는 단락을 모두 찾은 다음 해당 요소의 첫 글자만을 대상으로 하는 추상 개념입니다.\n 신문처럼 글의 첫 글자를 스타일로 꾸미는 데 자주 사용됩니다.\n 단락의 첫 줄 p::first-line { font-weight: bold; font-size: 1.2em; }   마찬가지로 ::first-line 가상 요소는 요소의 첫 번째 줄에만 스타일을 적용합니다.\n   9.4. (*) CSS 함수 (CSS Functional Notation)   Note  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions     9.4.1. 변환 함수 (Transform functions) matrix(a, b, c, d, tx, ty) 2D homogeneous 변환 행렬 설정\n matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) 3D homogeneous 변환 행렬 설정 (4×4)\n   Note  n = 길이 (10px, 10em, 1rem, 1cm …​)     perspective(n) 사용자와 z=0 평면 사이 거리를 n으로 설정\n   Note  a = 각도 (15deg, 0.1turn, .312rad …​)     rotate(ax, ay) 2D 평면의 고정점을 중심으로 요소 회전\n rotate3d(ax, ay, az) 3D 평면의 고정 축을 중심으로 요소 회전\n rotatex(ax) x축을 중심으로 요소를 회전\n rotatey(ay) y축을 중심으로 요소를 회전\n rotatez(az) z축을 중심으로 요소를 회전\n   Note  s = 비율 (0.7, 1.3 …​)     scale(sx, sy) 2D 평면에서 요소를 x축으로 sx 만큼, y축으로 sy 만큼 확대 또는 축소\n scale3d(sx, sy, sz) 2D 평면에서 요소를 x축으로 sx 만큼, y축으로 sy 만큼, z축으로 sz 만큼 확대 또는 축소\n scalex(sx) 요소를 x축으로 sx 만큼 확대 또는 축소\n scaley(sy) 요소를 y축으로 sy 만큼 확대 또는 축소\n scalez(sz) 요소를 z축으로 sz 만큼 확대 또는 축소\n skew(ax, ay) 2D 평면에서 요소를 ax 각도만큼 x축으로, ay 각도만큼 y축으로 기울여 왜곡시킴\n skewx(ax) 요소를 x축 방향으로 ax 각도만큼 기울여 왜곡시킴\n skewy(ay) 요소를 y축 방향으로 ay 각도만큼 기울여 왜곡시킴\n translate(nx, ny) 2D 평면에서 요소를 x, y 만큼 이동\n translate3d(nx, ny, nz) 3D 공간에서 요소를 x, y, z 만큼 이동\n translatex(nx) 요소를 x축 방향으로 \u0026#39;x\u0026#39; 만큼 이동\n translatey(ny) 요소를 y축 방향으로 \u0026#39;y\u0026#39; 만큼 이동\n translatez(nz) 요소를 z축 방향으로 \u0026#39;z\u0026#39; 만큼 이동\n  9.4.2. 수학 함수 (Math functions) CSS 숫자 값을 수학 표현식으로 작성\n calc() A math function that allows basic arithmetic to be performed on numerical CSS values.\n clamp() A comparison function that takes a minimum, central, and maximum value and represents its central calculation.\n max() A comparison function that represents the largest of a list of values.\n min() A comparison function that represents the smallest of a list of values.\n abs() Takes a calculation and returns the absolute value.\n Filter functions The \u0026lt;filter-function\u0026gt; CSS data type represents a graphical effect that can change the appearance of an input image. It is used in the filter and backdrop-filter properties.\n blur() Blurs the image.\n brightness() Makes the image brighter or darker.\n contrast() Increases or decreases the image’s contrast.\n drop-shadow() Applies a drop shadow behind the image.\n grayscale() Converts the image to grayscale.\n hue-rotate() Changes the overall hue of the image.\n invert() Inverts the colors of the image.\n opacity() Makes the image transparent.\n saturate() Super-saturates or desaturates the input image.\n sepia() Converts the image to sepia.\n Color functions Functions which specify different color representations. These may be used anywhere a \u0026lt;color\u0026gt; is valid.\n hsl() The HSL color model defines a given color according to its hue, saturation, and lightness components. An optional alpha component represents the color’s transparency.\n hsla() The HSL color model defines a given color according to its hue, saturation, and lightness components. The alpha component represents the color’s transparency.\n rgb() The RGB color model defines a given color according to its red, green, and blue components. An optional alpha component represents the color’s transparency.\n rgba() The RGB color model defines a given color according to its red, green, and blue components. The alpha component represents the color’s transparency.\n Image functions These functions may be used wherever an \u0026lt;image\u0026gt; is valid as the value for a property.\n conic-gradient() Conic gradients transition colors progressively around a circle.\n linear-gradient() Linear gradients transition colors progressively along an imaginary line.\n radial-gradient() Radial gradients transition colors progressively from a center point (origin).\n repeating-linear-gradiant() Is similar to linear-gradient() and takes the same arguments, but it repeats the color stops infinitely in all directions so as to cover its entire container.\n repeating-radial-gradient() Is similar to radial-gradient() and takes the same arguments, but it repeats the color stops infinitely in all directions so as to cover its entire container.\n repeat-conic-gradiant() Is similar to conic-gradient() and takes the same arguments, but it repeats the color stops infinitely in all directions so as to cover its entire container.\n cross-fade() Can be used to blend two or more images at a defined transparency.\n element() Defines an \u0026lt;image\u0026gt; value generated from an arbitrary HTML element.\n paint() Defines an \u0026lt;image\u0026gt; value generated with a PaintWorklet.\n Counter functions The counter functions are generally used with the content property, although in theory may be used wherever a \u0026lt;string\u0026gt; is supported.\n counter() Returns a string representing the current value of the named counter, if there is one.\n counters() Enables nested counters, returning a concatenated string representing the current values of the named counters, if there are any.\n symbols() Lets you define counter styles inline, directly as the value of a property.\n Font functions The font-variant-alternates property controls the use of alternate glyphs, the following functions are values for this property.\n stylistic() This function enables stylistic alternates for individual characters. The parameter is a font-specific name mapped to a number. It corresponds to the OpenType value salt, like salt 2.\n styleset() This function enables stylistic alternatives for sets of characters. The parameter is a font-specific name mapped to a number. It corresponds to the OpenType value ssXY, like ss02.\n character-variant() This function enables specific stylistic alternatives for characters. It is similar to styleset(), but doesn’t create coherent glyphs for a set of characters; individual characters will have independent and not necessarily coherent styles. The parameter is a font-specific name mapped to a number. It corresponds to the OpenType value cvXY, like cv02.\n swash() This function enables swash glyphs. The parameter is a font-specific name mapped to a number. It corresponds to the OpenType values swsh and cswh, like swsh 2 and cswh 2.\n ornaments() This function enables ornaments, like fleurons and other dingbat glyphs. The parameter is a font-specific name mapped to a number. It corresponds to the OpenType value ornm, like ornm 2.\n annotation() This function enables annotations, like circled digits or inverted characters. The parameter is a font-specific name mapped to a number. It corresponds to the OpenType value nalt, like nalt 2.\n Shape functions The following functions may be used as values for the \u0026lt;basic-shape\u0026gt; data type, which is used in the clip-path, offset-path, and shape-outside properties.\n circle() Defines a circle.\n ellipse() Defines an ellipse.\n inset() Defines an inset rectangle.\n polygon() Defines a polygon.\n path() Accepts an SVG path string to enable a shape to be drawn.\n Reference functions The following functions are used as a value of properties to reference a value defined elsewhere.\n attr() Used to retrieve the value of an attribute of the selected element and use it in the stylesheet.\n env() Used to insert the value of a user agent-defined environment variable.\n url() Used to include a file.\n var() Used to insert a value of a custom property instead of any part of a value of another property.\n CSS grid functions The following functions are used to define a CSS grid.\n fit-content() Clamps a given size to an available size according to the formula min(maximum size, max(minimum size, argument)).\n minmax() Defines a size range greater than or equal to min and less than or equal to max.\n repeat() Represents a repeated fragment of the track list, allowing a large number of columns or rows that exhibit a recurring pattern.\n   9.5. CSS Unit (반응형) CSS Unit (CSS 7가지 단위)\n 우리가 잘 알고 있는 CSS기술을 사용하는 것은 쉽고 간단할 수 있지만 새로운 문제에 봉착하게 되면 해결하기 어려울 수 있습니다. 웹은 항상 성장,변화하고 있고 새로운 해결방안 역시 계속 성장하고 있습니다. 그렇기 때문에 웹 디자이너와 프론트 엔드 개발자가 습득한 노하우를 활용할 수 밖에 없다는 것을 잘 알고 있습니다. 특별한 방법을 알면서, 단 한 번도 사용하지 않더라도 언젠가 필요한 때가 오면 정확한 방법을 실무에 적용할 수 있다는 뜻이기도 합니다. 이 글에서는 이전엔 알지 못했던 몇 가지의 CSS 방법에 대해 알아보고자 합니다. 몇몇 수치 단위들은 픽셀이나 em과 비슷하지만 다른 방법에 대해 살펴보도록 합니다.\n 9.5.1. rem (root em) 여러분에게 조금 익숙할 수 있는 단위로 시작해 보자면 em은 현재의 font-size를 정의합니다.\n 일례로, body 태그에 em값을 이용해 폰트 사이즈를 지정하면 모든 자식 요소들은 body의 폰트 사이즈에 영향을 받습니다.\n \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;test\u0026#34;\u0026gt;Test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;\u0026lt; CSS body { font-size: 14px; } div { font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px }   여기, div에 font-size를 1.2em으로 지정했습니다. 이 예제에서는 14px을 기준으로 1.2배의 폰트 사이즈로 표현이 됩니다. 결과적으로 16.8px의 크기가 됩니다.\n 그런데 여기 em으로 정의한 폰트 사이즈를 각각의 자식에 선언하면 어떤 일이 생길까요? 같은 CSS를 적용한 동일한 코드를 추가해보았습니다. 각각의 div는 각 부모의 폰트 사이즈를 상속받아 점점 커지게 됩니다.\n \u0026lt;div\u0026gt; Test (14 * 1.2 = 16.8px) \u0026lt;div\u0026gt; Test (16.8 * 1.2 = 20.16px) \u0026lt;div\u0026gt; Test (20.16 * 1.2 = 24.192px) \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   이것은 어떤 경우엔 바람직하겠지만 대부분의 경우, 단순하게 단일 사이즈로 표현하기도 합니다.\n 이런 경우 바로 rem 단위를 사용하면 됩니다.\n rem의 \u0026#34;r\u0026#34;은 바로 \u0026#34;root(최상위)\u0026#34;를 뜻합니다.\n 최상위 태그(요소)에 지정한 것을 기준으로 삼으며, 보통 최상위 태그는 html태그입니다.\n html { font-size: 14px; } div { font-size: 1.2rem; }   이전 예제에서 만든 복잡한 단계의 세 div는 모두 16.8px의 폰트 사이즈로 표현될 것입니다.\n 이 rem unit은 그리드 시스템에서도 유용하게 사용가능합니다.\n rem은 폰트에서만 사용하진 않습니다.\n 예를 들어, 그리드 시스템이나 rem을 이용한 기본 폰트 사이즈 기반으로 만든 UI 스타일, 그리고 em을 이용해 특정 위치에 특별한 사이즈를 지정할 수도 있습니다.\n 보다 정확한 폰트 사이즈나 크기 조정을 가능하게 해 줄 것입니다.\n .container { width: 70rem; /* 70 * 14px = 980px */ }   개념적으로 보면, 이 아이디어는 여러분의 콘텐츠 사이즈를 조절 할 수 있는 인터페이스 전략과 유사합니다. 그러나 모든 경우에 반드시 이런 방법을 따를 필요는 없습니다.\n rem (root em) 단위의 호환성은 caniuse.com에서 확인할 수 있습니다.\n  9.5.2. vh \u0026amp; vw (vertical height \u0026amp; vertical width) 반응형 웹디자인 테크닉은 퍼센트 값에 상당히 의존하고 있습니다.\n 하지만 CSS의 퍼센트 값이 모든 문제를 해결할 좋은 방법은 아닙니다. CSS의 너비 값은 가장 가까운 부모 요소에 상대적인 영향을 받습니다.\n 만약 타켓 요소의 너비값과 높이값을 뷰포트의 너비값과 높이값에 맞게 사용할 수 있다면 어떨까요?\n 바로 vh와 vw 단위가 그런 의도에 맞는 단위이고 vh 요소는 높이값의 100분의 1의 단위입니다.\n 예를 들어 브라우저 높이값이 900px일때 1vh는 9px이라는 뜻이 되지요. 그와 유사하게 뷰포트의 너비값이 750px이면 1vw는 7.5px이 됩니다.\n 이 규칙에는 무궁무진한 사용방법이 있습니다. 예를 들면, 최대 높이값이나 그의 유사한 높이값의 슬라이드를 제작할때 아주 간단한 CSS만 입력하면 됩니다.\n .slide { height: 100vh; }   스크린의 너비값에 꽉 차는 헤드라인을 만든다고 가정해 봅니다.\n vw로 폰트 사이즈를 지정하면 쉽게 달성할 수 있습니다.\n 해당 사이즈는 브라우저의 너비에 맞춰 변할 것입니다. (브라우저 크기를 늘였다 줄였다 해보세요)\n 뷰포트 vw, vh 단위의 호환성은 caniuse.com에서 확인할 수 있습니다.\n  9.5.3. vmin \u0026amp; vmax vh와 vw이 늘 뷰포트의 너비값과 높이값에 상대적인 영향을 받는다면 vmin과 vmax는 너비값과 높이값에 따라 최대, 최소값을 지정할 수 있습니다.\n 예를 들면 브라우저의 크기가 1100px 너비, 그리고 700px 높이일때 1vmin은 7px이 되고 1vmax는 11px이 됩니다.\n 너비값이 다시 800px이 되고 높이값이 1080px이 되면 vmin은 8px이 되고 vmax는 10.8px이 됩니다.\n 어때요, 이 값들을 사용할 수 있나요?\n 언제나 스크린에 보여지는 요소를 만든다고 가정해 봅니다.\n 높이값과 너비값을 vmin을 사용해 100으로 지정합니다.\n 예를 들어 터치화면 양 변에 가득차는 정사각형 요소를 만들때는 이렇게 정의하면 됩니다.\n .box { height: 100vmin; width: 100vmin; }   만약 커버처럼 뷰포트 화면에 보여야 하는(모든 네 변이 스크린에 꽉 차 있는) 경우에는 같은 값을 vmax로 적용하면 됩니다.\n .box { height: 100vmax; width: 100vmax; }   알려드린 이 규칙들을 잘 조합해 활용하면 뷰포트에 맞는 매우 유연한 방식으로 사이즈 조절을 가능하게 할 수 있습니다.\n 뷰포트 단위: vmin, vmax의 호환성은 caniuse.com에서 확인할 수 있습니다.\n  9.5.4. ex \u0026amp; ch ex와 ch 단위는 현재 폰트와 폰트 사이즈에 의존한다는 점에서 em 그리고 rem과 비슷합니다.\n em과 rem과 다른 점은 이 두 단위가 font-family에 의존한다면 다른 두 단위는 폰트의 특정 수치에 기반한다는 점입니다.\n ch 단위, 또는 글꼴 단위는 제로 문자인 0의 너비값의 \u0026#34;고급 척도\u0026#34;로 정의됩니다.\n 흥미로운 의견은 에릭 마이어의 블로그에서 확인할 수 있습니다. 그러나 기본 컨셉은 monospace 폰트의 N 의 너비값을 부여 받았다는 것이며, width: 40ch;는 40개의 문자열을 포함하고 있다는 뜻입니다.\n 이 특정 규칙은 점자 레이아웃에 기반하고 있지만, 이 기술의 가능성은 간단한 어플리케이션 그 이상으로 확장할 수 있습니다.\n ex 단위의 정의는 \u0026#34;현재 폰트의 x-높이값 또는 em의 절반 값\u0026#34;이라고 할 수 있습니다. x-높이값은 소문자 x의 높이값이기도 합니다. 폰트의 중간 지점을 알아내기 위해 자주 사용하는 방법입니다.\n 이 단위는 타이포그래픽에서 세밀한 조정을 할 때 많이 사용합니다.\n 예를 들어, 위첨자 태그인 sup 에게 position을 relative로 하고 bottom 값을 1ex라고 하면 위로 올릴 수 있습니다.\n 아래첨자 역시 비슷한 방법으로 아래로 내릴 수 있습니다.\n 브라우저는 위첨자와 아래첨자의 기본값을 vertical-align으로 정의하고 있지만, 보다 정교한 사용법을 알고 싶다면 아래와 같이 작성할 수 있습니다.\n sup { position: relative; bottom: 1ex; } sub { position: relative; bottom: -1ex; }   사용 가능 여부\n ex는 CSS1부터 있던 단위였고, ch 단위는 아직 찾을 수 없습니다.\n 마치며\n 여러분의 막강한 CSS 도구들의 무한한 확장과 지속되는 개발환경에 지속적으로 살펴보시기 바랍니다.\n 아마 특정 문제를 해결하기 위해 예상치 못한 해결방법으로 이 애매한 특정 단위들을 사용할 수도 있을 것입니다.\n 새로운 스펙들에 대해 시간을 투자해 보시기 바랍니다.\n 그리고 cssweekly와 같은 좋은 사이트에도 가입해서 지속적인 뉴스를 업데이트 받아보시기 추천합니다. 그리고 주간 업데이트에 가입하는 거 잊지 마세요.\n 무료 튜토리얼과 Tuts+의 웹디자인에서 나오는 다양한 자료들을 만날 수 있습니다.\n   Note  출처: https://webclub.tistory.com/356 [Web Club]       9.6. CSS Targeting Example p { color: var(--subtitle-color, blue); } /* \u0026lt;p\u0026gt; [CSS] */   #iA { color: var(--subtitle-color, blue); } /* \u0026lt;element id=\u0026#34;iA\u0026#34;\u0026gt; [CSS] */   [href] { color: var(--link-color, blue); } /* \u0026lt;element href\u0026gt; [CSS] */   .subtitle { color: var(--subtitle-color, blue); } /* \u0026lt;element class=\u0026#34;subtitle\u0026#34;\u0026gt; */   a#iA ul.subtitle a[style=\u0026#39;page-break-after: always\u0026#39;] { color: var(--subtitle-color, blue); } /* \u0026lt;a id=\u0026#34;iA\u0026#34;\u0026gt; ... \u0026lt;ul class=\u0026#34;subtitle\u0026#34;\u0026gt; ... \u0026lt;a style = \u0026#39;page-break-after: always\u0026#39;[CSS]\u0026gt; */    9.7. CSS Calculation Example .banner { width: calc(100% - 80px); --widthA: 100px; --widthB: calc(var(--widthA) / 2); /*50px*/ --widthC: calc(var(--widthB) / 2); /*25px*/ }    9.8. min()  9.9. max()  9.10. 추가   Note  출처: http://blog.hivelab.co.kr/%EA%B3%B5%EC%9C%A0before%EC%99%80after-%EA%B7%B8%EB%93%A4%EC%9D%98-%EC%A0%95%EC%B2%B4%EB%8A%94/ ① :first-child​(가상클래스)​​ – class를 지정하지 않아도 li의 첫번째 자식요소를​ 선택하여 제어할 수 있습니다. ② ::first-letter(가상요소) – li내의 첫번째 글자를 감싸고 있는 요소가 없어도 있는 것과 같이 제어해줄 수 있습니다. ① ::before – 실제 내용 바로 앞에서 생성되는 자식요소 ② ::after – 실제 내용 바로 뒤에서 생성되는 자식요소​\n ::before와 ::after를 쓸 땐 content라는 속성이 꼭 필요하다고 합니다! content는 또 어떤 것인지 알아보실까요?\n 1.3) content=”” 란?\n ::before와 ::after와 꼭 함께 쓰이는 ‘content’는 ‘가짜’ 속성입니다. HTML 문서에 정보로 포함되지 않은 요소를 CSS에서 새롭게 생성시켜주기 때문이죠!\n 아래의 표는 content를 쓸 때, 대표적으로 사용되는 속성들입니다. 2.1) gnb 구분 bar 넣기​\n 구분 bar가 포함된 서브네비게이션(snb, BreadCrumb)등 을 구성할 때 after를 사용한다면, 따로 클래스를 선언하지 않아도 쉽게 구현할 수 있습니다. 3 – 사용법 : li에 after와 content를 사용하여 바(|)를 선언 후, last-child를 이용하여 마지막 li의 content를 재선언 해줍니다. – 이슈 : last-child는 IE9부터 지원합니다. – 이슈해결 : before와 ​IE7, 8까지 지원되는 first-child를 활용법으로 변경할 수 있습니다.\n 아래와 같이 이슈해결이 가능합니다. 3-1\n 2.2) 앞,뒤에 추가 정보를 넣는 방법\n 특정 컨텐츠 앞, 뒤에 붙여지는 추가 정보들을 넣을 때도 편리하게 쓸 수 있습니다. 4 – 사용법 : 요소의 앞/뒤에 before 혹은 after를 선언합니다.. content=””에 넣고자 하는 문구를 입력해줍니다. – 이슈 : 강조하고 싶은 중요한 정보가 담겼다면, content를 스크린리더기에서도 꼭 읽어주어야 할텐데, 과연 스크린리더기에서 content의 내용을 읽어줄까요? – 이슈해결 : 목차 3번, 접근성이슈에서 관련 내용을 읽어보시고, 답을 찾아 보실 수 있습니다! 투비컨티뉴!\n        10. SASS (SCSS) CSS 전처리기\n 10.1. 명령어   변환 sass custom.scss custom.css\n  실시간 변환 (감시) sass --watch custom.scss custom.css\n  .map 소스맵(Sourcemap) 파일입니다. 컴파일된 소스를 원본 소스로 맵핑해 주는 역할, 원래 소스가 어디에 있는지 보여주는 지도\n  .map 없애기 sass --no-source-map custom.scss custom.css\n        Note  출처: https://nykim.work/97      10.2. 문법 10.2.1. Variables (변수) $ 기호를 사용하여 스타일시트에서 재사용하려는 정보를 저장.\n $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; }   body { font: 100% Helvetica, sans-serif; color: #333; }    10.2.2. Nesting (중첩) HTML과 동일한 시각적 계층 구조를 따르는 방식으로 CSS 선택기를 중첩.\n nav { ul { margin: 0; padding: 0; list-style: none; } li { display: inline-block; } a { display: block; padding: 6px 12px; text-decoration: none; } }   nav ul { margin: 0; padding: 0; list-style: none; } nav li { display: inline-block; } nav a { display: block; padding: 6px 12px; text-decoration: none; }    10.2.3. Partials (부분화) CSS 파일을 일부 나누어 모듈화 가능. 모듈 파일의 파일명 앞에 언더바 (_) 작성 후 @use 구문을 사용하여 로드.\n // _base.scss $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; }   // styles.scss @use \u0026#39;base\u0026#39;; .inverse { background-color: base.$primary-color; color: white; }    10.2.4. Mixins (그룹 변수) 여러 CSS 구문을 묶어 변수 형태로 전달 가능. @mixin 구문으로 선언.\n @mixin theme($theme: DarkGray) { background: $theme; box-shadow: 0 0 1px rgba($theme, .25); color: #fff; } .info { @include theme; } .alert { @include theme($theme: DarkRed); } .success { @include theme($theme: DarkGreen); }    10.2.5. Extend/Inheritance (확장/상속) 클래스와 같은 형태로 CSS 구문 선언 후 확장/상속 가능 % 구문으로 선언, @extend 구문으로 상속 및 확장.\n %message-shared { border: 1px solid #ccc; padding: 10px; color: #333; } /* 확장 된적 없으므로 CSS 파일에 기록 안됨 */ %equal-heights { display: flex; flex-wrap: wrap; } .message { @extend %message-shared; } .success { @extend %message-shared; border-color: green; }    10.2.6. Operators (연산자) +, -, *, math.div(), % 연산 바로 사용 가능 @use \u0026#34;sass:math\u0026#34; 구문으로 로드 후 사용 가능\n @use \u0026#34;sass:math\u0026#34;; .container { display: flex; } article[role=\u0026#34;main\u0026#34;] { width: math.div(600px, 960px) * 100%; } aside[role=\u0026#34;complementary\u0026#34;] { width: math.div(300px, 960px) * 100%; margin-left: auto; }       ","permalink":"https://cspidar.github.io/blog/posts/%EC%9B%B9/a-%EC%9B%B9-%EC%96%B8%EC%96%B4-html-css-javascript/","summary":"1. 관계         Node\n  Document\n  HTMLDocument\n     CharacterData\n  Text\n  Comment\n        Element\n  HTMLElement\n  HTMLHeadElement\n  HTMLLIElement\n        Attr\n      Element, Tag, Attribute, Property, Component \n      2.","title":"A - 웹 언어 (HTML, CSS, Javascript)"},{"content":" 1. arr의 v1과 v2의 value 서로 교체 / 교환 [arr[v1], arr[v2]] = [arr[v2], arr[v1]]     2. 2차 배열 정렬 / 0번 인덱스 같을때 1번 인덱스로 정렬 arr.sort((a, b) =\u0026gt; { if (a[0] === b[0]) return a[1] - b[1]; else return a[0] - b[0]; });     3. 2차 배열 회전 // arr 회전 - 좌 function rotateLeft(array) { var result = []; array.forEach((a, i, aa) =\u0026gt; { a.forEach((b, j, bb) =\u0026gt; { result[bb.length - j - 1] = result[bb.length - j - 1] || []; result[bb.length - j - 1][i] = b; }); }); return result; } // arr 회전 - 우 function rotateRight(array) { var result = []; array.forEach((a, i, aa) =\u0026gt; { a.forEach((b, j, bb) =\u0026gt; { result[j] = result[j] || []; result[j][aa.length - i - 1] = b; }); }); return result; }     4. 특정 v의 모든 i res에 추가 let res = []; let idx = arr.indexOf(v); while (idx != -1) { res.push(idx); idx = arr.indexOf(v, idx + 1); }     ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%BD%94%EB%93%9C/%EB%B0%B0%EC%97%B4-%ED%99%9C%EC%9A%A9/","summary":"1. arr의 v1과 v2의 value 서로 교체 / 교환 [arr[v1], arr[v2]] = [arr[v2], arr[v1]]     2. 2차 배열 정렬 / 0번 인덱스 같을때 1번 인덱스로 정렬 arr.sort((a, b) =\u0026gt; { if (a[0] === b[0]) return a[1] - b[1]; else return a[0] - b[0]; });     3. 2차 배열 회전 // arr 회전 - 좌 function rotateLeft(array) { var result = []; array.forEach((a, i, aa) =\u0026gt; { a.","title":"자바스크립트 알고리즘 - 코드 - 배열 활용"},{"content":" 1. arr → map 변환 const map = new Map([ [k1, v1], [k2, v2], [...k, ...v], ]);     2. map →\u0026gt; arr 변환 (펼침 연산자) let arr = [...map];     3. value 업데이트 map.set(k, map.get(k) + 1);     4. 순회 for ([key, value] of map) { }     5. Function - 두 Map 일치 확인 function chkMaps(p1, p2) { // console.log(p1); if (p1.size != p2.size) return false; else { for ([k, v] of p1) { if (!p2.has(k) || p2.get(k) !== v) return false; // p2에 p1의 k가 있는지 확인 || p2의 v가 p1의 v와 같은지 확인 } return true; } }     ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%BD%94%EB%93%9C/%EB%A7%B5-%ED%99%9C%EC%9A%A9/","summary":"1. arr → map 변환 const map = new Map([ [k1, v1], [k2, v2], [...k, ...v], ]);     2. map →\u0026gt; arr 변환 (펼침 연산자) let arr = [...map];     3. value 업데이트 map.set(k, map.get(k) + 1);     4. 순회 for ([key, value] of map) { }     5. Function - 두 Map 일치 확인 function chkMaps(p1, p2) { // console.","title":"자바스크립트 알고리즘 - 코드 - Map 활용"},{"content":" 이것이 취업을 위한 코딩 테스트다 with 파이썬 (한빛미디어, 나동빈 저) 책 내 문제의 자바스크립트 풀이 코드입니다. 더 나은 풀이를 전달해 주시면 업데이트 하도록 하겠습니다.\n 1. 12-10 자물쇠와 열쇠 function solution(p1, p2) { // const key = [...p1]; const lock = [...p2]; const large_lock = Array.from(Array(3 * lock.length), () =\u0026gt; Array(3 * lock.length).fill(0), ); for (let i = 0; i \u0026lt; lock.length; i++) { for (let j = 0; j \u0026lt; lock.length; j++) { large_lock[lock.length + i][lock.length + j] = lock[i][j]; } } let ans = \u0026#39;FALSE\u0026#39;; for (i = 1; i \u0026lt;= 4; i++) { let key2 = Right(key); for (let m = 0; m \u0026lt; lock.length * 2; m++) { for (let n = 0; n \u0026lt; lock.length * 2; n++) { // for (let i = 0; i \u0026lt; key.length; i++) { for (let j = 0; j \u0026lt; key.length; j++) { large_lock[m + i][n + j] += key2[i][j]; } } let flag = 1; for (let i = 0; i \u0026lt; lock.length; i++) { for (let j = 0; j \u0026lt; lock.length; j++) { if (large_lock[lock.length + i][lock.length + j] !== 1) flag = 0; } } if (flag === 1) { ans = \u0026#39;TURE\u0026#39;; break; } for (let i = 0; i \u0026lt; key.length; i++) { for (let j = 0; j \u0026lt; key.length; j++) { large_lock[m + i][n + j] -= key2[i][j]; } } } } } console.table(large_lock); function Right(array) { var result = []; array.forEach((a, i, aa) =\u0026gt; { a.forEach((b, j, bb) =\u0026gt; { result[j] = result[j] || []; result[j][aa.length - i - 1] = b; }); }); return result; } return ans; } const in1 = [ [0, 0, 0], [1, 0, 0], [0, 1, 1], ]; const in2 = [ [1, 1, 1], [1, 1, 0], [1, 0, 1], ]; const in3 = 0; const in4 = 0; const in5 = 0; console.log(solution(in1, in2, in3, in4, in5));     ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9D%B4%EC%BD%94%ED%85%8C/12-10_%EC%9E%90%EB%AC%BC%EC%87%A0%EC%99%80-%EC%97%B4%EC%87%A0/","summary":"이것이 취업을 위한 코딩 테스트다 with 파이썬 (한빛미디어, 나동빈 저) 책 내 문제의 자바스크립트 풀이 코드입니다. 더 나은 풀이를 전달해 주시면 업데이트 하도록 하겠습니다.\n 1. 12-10 자물쇠와 열쇠 function solution(p1, p2) { // const key = [...p1]; const lock = [...p2]; const large_lock = Array.from(Array(3 * lock.length), () =\u0026gt; Array(3 * lock.length).fill(0), ); for (let i = 0; i \u0026lt; lock.length; i++) { for (let j = 0; j \u0026lt; lock.","title":"자바스크립트 알고리즘 - 이코테 - 12-10 자물쇠와 열쇠"},{"content":" 본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. Function 1.1. 주의사항 this 키워드는 함수 내에서 현재 실행 중인 함수를 참조하지 않으므로 이름으로 Function 객체를 직접 참조해야 함 (bind() 메소드 활용 이유)\n    2. Function 프로퍼티 2.1. Function.length func.length // func의 p 갯수 반환   /// 예시 function func(a, b) =\u0026gt; a + b; func.length //\u0026gt; 2    2.2. Function.name func.name // func의 이름 반환      3. Function 메소드 3.1. 관련 요소 반환 3.1.1. Function.prototype.bind() func.bind(p_this, p1, p2, ...p) // p_this와 하나 이상의 p로 새로운 함수를 생성     3.2. Function.prototype.toString() func.toString() // func의 소스 코드를 str 반환    3.3. 호출 3.3.1. Function.prototype.apply() func.apply(p_this, [p1, p2, .. p]) //p_this와 하나 이상의 p (arr 형태)로 func 호출 // call() 와 유사, // call(p_this, p1, p2, ...p) / apply(p_this, arr)    3.3.2. Function.prototype.call() func.call(p_this, p1, p2, ...p) //p_this와 하나 이상의 p로 func 호출     3.4. 기타 눌러서 확인   AggregateError\n// 다수의 에러가 한 에러로 랩핑되어야 할 때의 오류를 나타냅니다.   /// 예시 Promise.any([ Promise.reject(new Error(\u0026#34;some error\u0026#34;)), ]).catch(e =\u0026gt; { console.log(e instanceof AggregateError); //\u0026gt; true console.log(e.message); //\u0026gt; All Promises rejected\u0026#34; console.log(e.name); // \u0026#34;AggregateError\u0026#34; console.log(e.errors); // [ Error: \u0026#34;some error\u0026#34; ] });           4. 활용 4.1. getter  4.2. setter    ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/g-%ED%95%A8%EC%88%98-%EB%A9%94%EC%86%8C%EB%93%9C-function-methods/","summary":"본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. Function 1.1. 주의사항 this 키워드는 함수 내에서 현재 실행 중인 함수를 참조하지 않으므로 이름으로 Function 객체를 직접 참조해야 함 (bind() 메소드 활용 이유)\n    2. Function 프로퍼티 2.1. Function.length func.length // func의 p 갯수 반환   /// 예시 function func(a, b) =\u0026gt; a + b; func.","title":"자바스크립트 문법 - G - 함수 주요 메소드 (Function methods essential)"},{"content":" 본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. Set 1.1. 특징   유일한 값을 저장, 객체와 원시 값 모두 저장 가능\n  index 없음\n  item 순서에 의미 없음\n  개별 item에 접근 불가\n    1.2. 기본 문법 1.2.1. 선언 const set = new Set()       2. Set 프로퍼티 2.1. Set.prototype.size set.size // set의 item 갯수 반환 // set.length 는 값이 0인 속성      3. Set 메소드 3.1. 직접 수정 3.1.1. Set.prototype.add() set.add(a1).add(a2).add(...a) // set의 뒤에 하나 이상의 item을 추가, 수정된 set 반환\t직접 수정    3.1.2. Set.prototype.clear() set.clear() // set의 모든 item을 제거 (원본 set 변경), undefined 반환\t직접 수정     3.2. 확인 \u0026amp; 검색 3.2.1. Set.prototype.delete() set.delete(i) // set의 i를 제거, 제거 여부 true/false 반환    3.2.2. Set.prototype.has() set.has(i) // i의 존재 여부 확인, true/false 반환\t확인     3.3. 관련 요소 반환 3.3.1. Set.prototype.forEach() set.forEach((p) =\u0026gt; p + 1) // set의 item에 차례로 연산 함수 적용, 중간 탈출 불가, undefine 반환\t변환    3.3.2. Set.prototype.keys() set.keys() // set의 item을 차례로 제공하는 새로운 iterator 반환\t관련    3.3.3. Set.prototype.values() set.values() // set의 item을 차례로 제공하는 새로운 iterator 반환\t관련    3.3.4. Set.prototype.entries() set.entries() // set의 [item, item] 형태의 arr을 차례로 제공하는 iterator 반환\t관련 요소 // Map과 호환을 위한 기능     3.4. 기타 눌러서 확인   get Set[@@species]\nSet[Symbol.species] // 값이 0인 속성, item 수는 Set.prototype.size로 확인 가능     Set.prototype[@@iterator]()\nset[Symbol.iterator]() // set의 item을 차례로 제공하는 iterator 반환\t관련 요소 // values() 와 같음           4. 활용 4.1. arr ↔ set 변환 /// arr -\u0026gt; set 변환 const set = new Set(arr);   /// set -\u0026gt; arr 변환 - 1 const arr = Array.from(set);   /// set -\u0026gt; arr 변환 - 2 (펼침 연산자) [...set] //\u0026gt; [i1, i2, ...i]\u0026#34;    4.2. arr 중복 제거 // arr -\u0026gt; set -\u0026gt; arr2 const arr = [1, 1, 2] const arr2 = [...new Set(arr)] //\u0026gt; [1, 2]    4.3. 집합 연산 let setA = new Set([1, 2, 3, 4, 5]) let setB = new Set([4, 5, 6, 7, 8])   /// 합집합 let uSet = new Set([...setA, ...setB]) for (let value of uSet) { console.log(value); } //\u0026gt; 1, 2, 3, 4, 5, 6, 7, 8   /// 교집합 let iSet = new Set([...setA].filter(v =\u0026gt; setB.has(v))); for (let value of iSet) { console.log(value) } //\u0026gt; 4, 5   /// 차집합 let dSet = new Set([...setA].filter(v =\u0026gt; !setB.has(v))); for (let value of dSet) { console.log(value) } //\u0026gt; 1, 2, 3   /// 여집합 var setA = new Set([1, 2, 3, 4, 5]); var setB = new Set([3, 4, 5, 6, 7]); var sdSet = new Set( [...[...set1].filter(x =\u0026gt; !setB.has(x)), ...[...setB].filter(x =\u0026gt; !setA.has(x))] ) for (let value of sdSet) { console.log(value) } //\u0026gt; 1, 2, 6, 7      ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/f-%EC%85%8B-%EB%A9%94%EC%86%8C%EB%93%9C-set-methods/","summary":"본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. Set 1.1. 특징   유일한 값을 저장, 객체와 원시 값 모두 저장 가능\n  index 없음\n  item 순서에 의미 없음\n  개별 item에 접근 불가\n    1.2. 기본 문법 1.2.1. 선언 const set = new Set()       2.","title":"자바스크립트 문법 - F - 셋 주요 메소드 (Set methods essential)"},{"content":" 본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. Map 1.1. 특징   key, value 쌍을 저장하며 삽입 순서도 기억하는 컬렉션\n     객체 (Object) 대신 맵 (Map) 을 사용해야 하는 경우\n 동적인 대상을 컬렉션화 할 경우\n  Object는 경로를 알고 있는 정적인 정보에 적합. 갱신, 반복, 대체 정렬해야 할 정보에는 적절하지 않음\n  탐색 성능에서 Map이 더 뛰어남\n     숫자 또는 Object를 key로 사용해야 하는 경우\n  Object의 키는 반드시 String 또는 Symbol이어야 함\n  이외의 값을 key로 사용해야 할 경우에 Map 사용\n     컬렉션을 순회해야 할 경우\n  Object를 순회하려면 다른 형태로 변환 (복잡) 하거나, for in 문을 사용 (key 값 외에는 접근 불가) 해야하고 모든 경우에 순서 보장되지 않음\n  순회를 용이하게 하려면 Map 사용\n             맵 (Map) 과 객체 (Object) 의 차이점\n 기본 key\n  Map: 제공한 키 외에는 어떤 키도 가지지 않음\n  Object: 프로토타입을 가지므로 기본 키 존재 가능, 제공한 키와 충돌 가능\n     가능 key\n  Map: 숫자, 객체 등을 포함한 모든 값 가능\n  Object: String 또는 Symbol\n     key 순서\n  Map: 정렬됨. 삽입 순서에 따라 순회\n  Object: 키는 정렬되지 않음. (ECMEScript 2015 준수 엔진에서 문자열 키만 가진 객체는 정렬됨)\n     크기\n  Map: size 속성으로 바로 확인 가능\n  Object: 구조 변경등의 부수 작업 필요\n     순회\n  Map: 바로 순회 가능 (for of, forEach 로 접근 가능, [key,value] of map 으로 key, value 따로 접근 가능)\n  Object: 순회하려면 먼저 모든 키를 알아낸 후, 그 키의 배열을 순회해야 함 (for in 순회 가능하나 느리고 순서 보장 안함)\n     성능\n  Map: 잦은 src 추가와 제거에서 더 좋은 성능\n  Object: src 추가와 제거를 위한 최적화 없음\n            1.2. 기본 문법 1.2.1. 선언 const map = new Map()    1.2.2. src 추가 map.set(key, value)    1.2.3. value 호출 map.get(key)       2. Map 프로퍼티 2.1. Map.prototype.size map.size // map의 src 갯수 반환 // map.length 는 값이 0인 속성      3. Map 메소드 3.1. 직접 수정 3.1.1. Map.prototype.clear() map.clear() // map의 모든 src를 제거 (원본 map 변경), undefined 반환    3.1.2. Map.prototype.delete() map.delete(key) // map의 key 관련 src를 제거, 제거 여부 true/false 반환     3.2. 확인 \u0026amp; 검색 3.2.1. Map.prototype.get() map.get(key) // map의 key에 해당하는 value 반환, 없으면 undefined 반환    3.2.2. Map.prototype.set() map.set(k1, v1).set(k2, v2).set(...k, ...v) // map에 하나 이상의 src 추가 및 갱신    3.2.3. Map.prototype.has() map.has(key) // key의 존재 여부 확인, true/false 반환     3.3. 관련 요소 반환 3.3.1. Map.prototype.forEach() map.forEach((value, key) =\u0026gt; value + 1) // map의 src에 차례로 연산 함수 적용, 중간 탈출 불가, undefine 반환 // 연산 함수의 value, key 순서에 주의 // forEach 의 경우, 인자 순서가 이상한데(key, value 순서가 반대) Array.prototype.forEach() 구문과 통일성을 유지하기 위함(value, index, array 순서인 것)    3.3.2. Map.prototype.keys() map.keys() // map의 key를 차례로 제공하는 새로운 iterator 반환    3.3.3. Map.prototype.values() map.values() // map의 value를 차례로 제공하는 새로운 iterator 반환    3.3.4. Map.prototype.entries() map.entries() // map의 src 배열을 차례로 제공하는 iterator 반환     3.4. 기타 눌러서 확인   get Map[@@species]\nMap[Symbol.species] // 값이 0인 속성, src 수는 Map.prototype.size로 확인 가능     Map.prototype[@@toStringTag]\nObject.prototype.toString.call(new Map()) // 파생 객체를 생성하는데 사용하는 생성자 함수     Map.prototype[@@iterator]()\nmap[Symbol.iterator]() // map의 src를 차례로 제공하는 iterator 반환 // entries() 와 같음           4. 활용 4.1. obj ↔ map 변환 /// obj -\u0026gt; map 변환 (Object.entries) let obj = {name: \u0026#34;John\u0026#34;, age: 30}; let map = new Map(Object.entries(obj)); map.get(\u0026#39;name\u0026#39;) //\u0026gt; John   /// map -\u0026gt; obj 변환 (Object.fromEntries) let map = new Map(); map.set(\u0026#39;a\u0026#39;, 1); map.set(\u0026#39;b\u0026#39;, 2); let obj = Object.fromEntries(map.entries()); //\u0026gt; obj = { a: 1, b: 2 }    4.2. arr ↔ map 변환 /// arr -\u0026gt; map 변환 const map = new Map ([[k1, v1],[k2, v2],[...k, ...v]])   /// map -\u0026gt;\u0026gt; arr 변환 (펼침 연산자) [...map] //\u0026gt; [[k1, v1], [k2, v2], [...k, ...v]]      ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/e-%EB%A7%B5-%EB%A9%94%EC%86%8C%EB%93%9C-map-methods/","summary":"본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. Map 1.1. 특징   key, value 쌍을 저장하며 삽입 순서도 기억하는 컬렉션\n     객체 (Object) 대신 맵 (Map) 을 사용해야 하는 경우\n 동적인 대상을 컬렉션화 할 경우\n  Object는 경로를 알고 있는 정적인 정보에 적합.","title":"자바스크립트 문법 - E - 맵 주요 메소드 (Map methods essential)"},{"content":" 본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. 문자열 프로퍼티 1.1. String.length str.length //\u0026gt; str의 문자 개수 반환      2. 문자열 메소드 2.1. 변환 2.1.1. String.prototype.concat() str.concat(\u0026#39;s1\u0026#39;, \u0026#39;s2\u0026#39;, ...\u0026#39;s\u0026#39;) //\u0026gt; str에 하나 이상의 \u0026#39;s\u0026#39;를 합쳐 새로운 str로 반환    2.1.2. String.prototype.slice() str.slice(start, end) //\u0026gt; start부터 end (옵션: 기본 str.length) 전까지 (end 미포함) string을 새로운 str로 반환    2.1.3. String.prototype.substring() str.substring(start, end) //\u0026gt; str을 start 부터 end 전까지 (end 미포함) (옵션 - 기본: str.length) 새로운 str로 반환   slice, substring 차이점? 음수인덱스일 경우, slice()는 역방향으로 카운트 / substring() 은 0으로 치환됨 start 가 end 보다 큰 경우, slice()는 빈 문자열 반환 / substring() 은 마치 두 개의 인자를 바꾼 듯 작동 인자가 str.length 보다 큰 경우, substring()은 str.length 로 치환해서 처리 / slice()는 start 가 str.length 큰 경우에는 빈 문자열 반환, end 가 str.length 보다 큰 경우에는 strLength 로 치환\n   동일한 입력값, 동일한 결과값이 나오는 경우\n// start, end 모두 없는 경우 \u0026#34;CARROT\u0026#34;.slice() // result : \u0026#34;CARROT\u0026#34; \u0026#34;CARROT\u0026#34;.substring() // result : \u0026#34;CARROT\u0026#34;   // start index 양수 하나인 경우 \u0026#34;CARROT\u0026#34;.slice(3) // result : \u0026#34;ROT\u0026#34; \u0026#34;CARROT\u0026#34;.substring(3) // result : \u0026#34;ROT\u0026#34;   // start === end 인 경우 \u0026#34;CARROT\u0026#34;.slice(3, 3) // result : \u0026#34;\u0026#34; \u0026#34;CARROT\u0026#34;.substring(3, 3) // result : \u0026#34;\u0026#34;     start \u0026gt; end\n\u0026#34;CARROT\u0026#34;.slice(4,2) // result : \u0026#34;\u0026#34; \u0026#34;CARROT\u0026#34;.substring(4,2) // result : \u0026#34;RR\u0026#34; -\u0026gt; 마치 두 개의 인자를 바꾼 듯 작동     음수 인덱스\n\u0026#34;CARROT\u0026#34;.slice(-2) // result : \u0026#34;OT\u0026#34; -\u0026gt; 역방향 인덱스부터 시작 \u0026#34;CARROT\u0026#34;.substring(-2) // result : \u0026#34;CARROT\u0026#34; -\u0026gt; 음수인 경우, 0으로 치환 \u0026#34;CARROT\u0026#34;.slice(2, -2) // result : \u0026#34;RR\u0026#34; -\u0026gt; start 는 정방향, end 는 역방향 \u0026#34;CARROT\u0026#34;.substring(2, -2) // result : \u0026#34;CA\u0026#34; -\u0026gt; 음수가 0으로 치환, start \u0026gt; end 이므로 swap     start or end \u0026gt; str.length\n\u0026#34;CARROT\u0026#34;.slice(10, 2) // result : \u0026#34;\u0026#34; \u0026#34;CARROT\u0026#34;.substring(10, 2) // result : \u0026#34;RROT\u0026#34; -\u0026gt; swap 된 후, 10이 strLength로 치환   출처: https://interacting.tistory.com/144\n       2.1.4. String.prototype.split() str.split(\u0026#39;s\u0026#39;, n) // str을 \u0026#39;s\u0026#39; 구분자 (옵션: 기본 구분자 없음) 로 n 개 (옵션: 기본 str.length) 까지 분할해 새로운 arr로 반환     관련 메소드\narr.join(\u0026#39;s\u0026#39;) // arr의 모든 item을 사이에 \u0026#39;s\u0026#39; 구분자를 넣어 더해 새로운 str로 반환, item이 undefined 또는 null이면 빈 str로 반환       2.1.5. String.prototype.toLowerCase() str.toLowerCase() // str을 소문자로 변환하여 새로운 str로 반환    2.1.6. String.prototype.toUpperCase() str.toUpperCase() // str을 대문자로 변환하여 새로운 str로 반환    2.1.7. String.prototype.padStart() str.padStart(n, \u0026#39;s\u0026#39;) str의 길이가 n이 될때까지 \u0026#39;s\u0026#39;를 좌측부터 채워 새로운 str로 반환     예시\nconst str = \u0026#39;abcd\u0026#39; str.padStart(10, \u0026#39;.\u0026#39;) //\u0026gt; \u0026#34;......abcd\u0026#34;       2.1.8. String.prototype.padEnd() str.padEnd(n, \u0026#39;s\u0026#39;) str의 길이가 n이 될때까지 \u0026#39;s\u0026#39;를 우측부터 채워 새로운 str을 반환합니다.     예시\nconst str = \u0026#39;abcd\u0026#39; str.padEnd(10, \u0026#39;.\u0026#39;) //\u0026gt; \u0026#34;abcd......\u0026#34;       2.1.9. String.prototype.repeat() str.repeat(n); //str을 n번 반복해 붙인 새로운 str 반환    2.1.10. String.prototype.replace() - string // 보강 필요 str.replace(\u0026#39;r1/s1\u0026#39;, \u0026#39;s2\u0026#39;) // str의 r1/s1과 일치하는 첫 부분을 s2로 교체한 새로운 str 반환     예시\nconst str = \u0026#39;aabbcc\u0026#39; str.replace(\u0026#39;b\u0026#39;, \u0026#39;k\u0026#39;) //\u0026gt; \u0026#34;aakbcc\u0026#34;        특수 페턴\n  $$: \u0026#34;$\u0026#34; 기호 삽입\n  $\u0026amp;: 매치된 문자열을 삽입합니다.\n  $`: 매치된 문자열 앞쪽까지의 문자열을 삽입합니다.\n  $\u0026#39;: 매치된 문자열의 문자열을 삽입합니다.\n  $n: n이 1이상 99이하의 정수라면, 첫번째 매개변수로 넘겨진 RegExp객체에서 소괄호로 묶인 n번째의 부분 표현식으로 매치된 문자열을 삽입합니다.\n       2.1.11. String.prototype.replace() - func // 보강 필요 str.replace(\u0026#39;r/s1\u0026#39;, p =\u0026gt; p + 1) // str의 r1/s1과 일치할 경우 연산 함수 호출, 연산 결과를 문자열로 반환     특수 페턴은 반환값에 적용되지 않음, 정규표현식의 플래그로 글로벌(g)이 오는 경우, 일치될 때마다 계속 함수 호출\n     함수 p\n  match: 일치 string (특수 페턴 $\u0026amp; 표현식으로 매치된 경우와 동일)\n  p1, p2, …​p: 특수 페턴 $n 표현식과 동일 ($1은 p1, $2는 p2) (정규표현식 /(\\a+)(\\b+)/ 이 주어진다면 p1은 \\a+, p2는 \\b+와 매치)\n  offset: 일치 string의 index (예를 들어, 조사될 전체 문자열이 abcd이고, 매치된 문자열이 bc면 이 매개변수의 값은 1이 됩니다.)\n  string: 조사된 전체 문자열 (replace를 호출한 str)\n       2.1.12. String.prototype.replaceAll() str.replaceAll(\u0026#39;r/s1\u0026#39;, \u0026#39;s2\u0026#39;) // str의 r1/s1과 일치하는 모든 부분을 s2로 교체한 새로운 str 반환     예시\nconst str = \u0026#39;aabbcc\u0026#39; str.replace(\u0026#39;b\u0026#39;, \u0026#39;k\u0026#39;) //\u0026gt; \u0026#34;aakkcc\u0026#34;   특수 페턴 적용\n     2.1.13. String.prototype.replaceAll() str.replaceAll(\u0026#39;r/a1\u0026#39;, p =\u0026gt; p + 1) // str의 string이 r1/a1과 일치할 경우 연산 함수 호출, 연산 결과를 문자열로 반환     예시\nconst str = \u0026#39;aabbcc\u0026#39; str.replace(\u0026#39;b\u0026#39;, \u0026#39;k\u0026#39;) //\u0026gt; \u0026#34;aakkcc\u0026#34;   특수 페턴은 반환값에 적용되지 않음 함수 P 적용\n     2.1.14. String.prototype.toString() H.toString() // H를 str로 변환하여 반환     2.2. 검색 \u0026amp; 확인 2.2.1. String.prototype.includes() str.includes(\u0026#39;s\u0026#39;, start) // str의 \u0026#39;s\u0026#39;의 존재 여부를 start (옵션: 기본 0) 부터 차례로 확인, true/false 반환    2.2.2. String.prototype.indexOf() str.indexOf(\u0026#39;s\u0026#39;, start) // str의 \u0026#39;s\u0026#39;의 존재 여부를 start (옵션: 기본 0) 부터 차례로 확인, index를 반환, 없으면 -1 반환    2.2.3. String.prototype.lastIndexOf() str.lastIndexOf(\u0026#39;s\u0026#39;, end) // indexOf() 와 달리 end부터 (옵션 - 기본: 1/0) 역순으로 검색    2.2.4. String.prototype.startsWith() str.startsWith(\u0026#39;s\u0026#39;, n) // str의 시작과 \u0026#39;s\u0026#39;의 일치 여부를 n 번째 index (옵션 - 기본: 0) 부터 확인, true/false 반환    2.2.5. String.prototype.search() str.search(r/) // str에서 r/과 일치하는 항목 검색, 일치하는 첫번째 index 반환, 없으면 -1 반환    2.2.6. String.prototype.endsWith() str.endsWith(\u0026#39;s\u0026#39;)) //str의 마지막과 \u0026#39;s\u0026#39; 와의 일치 여부를 true/false 로 반환     예시\nconst str = \u0026#39;abcdef\u0026#39; str.endsWith(\u0026#39;def\u0026#39;) // true str.endsWith(\u0026#39;bc\u0026#39;) // false       2.2.7. String.prototype.at() str.at(index) // 실험 기능 // str의 index에 해당하는 글자 반환 // charAt() 과 차이점: index 음수 가능    2.2.8. String.prototype.charAt() str.at(index) // str의 index (옵션 - 기본: 0) 에 해당하는 글자 반환 // at() 과 차이점: index 음수 불가     2.3. 기타 2.3.1. String.prototype.trim() str.trim() // str 양 끝의 모든 공백문자(space, tab, NBSP 등)와 모든 개행문자(LF, CR 등)를 제거, 새로운 str 반환    2.3.2. String.prototype.trimEnd() /\tString.prototype.trimRight() str.trimEnd() // str 끝의 모든 공백문자(space, tab, NBSP 등)와 모든 개행문자(LF, CR 등)를 제거, 새로운 str 반환    2.3.3. String.prototype.trimStart() / String.prototype.trimLeft() str.trimStart // str 시작의 모든 공백문자(space, tab, NBSP 등)와 모든 개행문자(LF, CR 등)를 제거, 새로운 str 반환    2.3.4. String.prototype.charCodeAt() str.charCodeAt(index) // str의 index (옵션 - 기본: 0) 에 해당하는 글자를 UTF-16 코드로 반환    2.3.5. String.fromCharCode() String.fromCharCode(n) // n (UTF-16 코드) 을 str로 반환     예시\nString.fromCharCode(189, 43, 190, 61) //\u0026gt; \u0026#34;½+¾=\u0026#34;       2.3.6. String.prototype.codePointAt() str.codePointAt(index) // str의 index (옵션 - 기본: 0) 에 해당하는 글자의 코드 포인트 값을 반환 //charCodeAt() 과 차이점: 일반 문자의 경우 반환값이 동일하지만, 단일 UTF-16 코드로 표현할 수 없는 문자 (ex. 이모지) 는 다름   http://www.devdic.com/javascript/refer/native/method:1371/codePointAt()\n  2.3.7. String.fromCodePoint() String.fromCodePoint(n) // n (코드 포인트) 를 str로 반환     예시\nString.fromCodePoint(9731, 9733, 9842, 0x2F804) //\u0026gt; \u0026#34;☃★♲你\u0026#34;       2.3.8. String.prototype.localeCompare() str.localCompare(\u0026#39;s\u0026#39;) //str과 \u0026#39;s\u0026#39;의 정렬 순서에 따른 숫자 반환 (str - \u0026#39;s\u0026#39;: -1, str = \u0026#39;s\u0026#39;: 0, \u0026#39;s\u0026#39; - str: 1)    2.3.9. String.prototype.normalize() str.normalize(form) // str을 form (유니코드 정규화 방식, Unicode Normalization Form)에 따라 정규화된 형태로 반환, str이 문자열이 아닐 경우에는 우선 문자열로 변환 후 정규화     form\n  NFC — 정규형 정준 결합(Normalization Form Canonical Composition).\n  NFD — 정규형 정준 분해(Normalization Form Canonical Decomposition).\n  NFKC — 정규형 호환성 결합(Normalization Form Compatibility Composition).\n  NFKD — 정규형 호환성 분해(Normalization Form Compatibility Decomposition)\n       2.3.10. String.raw String.raw`{a}` // 템플릿의 표현식의 결과를 그대로 표현하여 출력합니다. 특수문자와 유니코드는 문자열로 인식합니다.     예시\nString.raw`Hi\\n${2+3}!` //\u0026gt; \u0026#34;Hi\\n5!\u0026#34;   https://mollangk.tistory.com/32\n     2.3.11. String.raw() String.raw({raw:str}, a1, a2, …a) // str과 하나 이상의 a를 차례로 1개씩 합친 새로운 str 반환     예시\nconst one = 1 String.raw({raw:\u0026#39;ABDCEF\u0026#39;}, one, 2) //\u0026gt; \u0026#34;A1B2DCEF\u0026#34;   https://mollangk.tistory.com/32\n     2.3.12. String.prototype.toLocaleLowerCase() H.toLocaleLowerCase() // 숫자 및 숫자가 포함된 대상을 지역에 따른 표현을 적용한 소문자 str로 반환 (원본 H 유지)    2.3.13. String.prototype.toLocaleUpperCase() H.toLocaleUpperCase() // 숫자 및 숫자가 포함된 대상을 지역에 따른 표현을 적용한 대문자 str로 반환 (원본 H 유지)    2.3.14. String.prototype.match() str.match(regexp) // 정규표현식 // str이 regexp와 일치하면, 일치하는 전체 str을 첫번째 item으로 하고 이후 괄호 한 캡처 결과를 포함하는 arr 반환, 일치 항목이 없으면 null 반환 // 정규식에 g 플래그가 포함되어있지 않으면, str.match() 는 RegExp.exec()와 같은 결과를 반환 // 정규식에 g 플래그가 포함되어 있으면, 일치는 객체가 아닌 일치하는 하위 문자열을 포함하는 Array를 반환합니다. 캡처된 그룹은 반환되지 않습니다. 일치하는 것이 없으면 null이 반환됩니다.   https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match\n   관련 메소드\n  RegExp.test(): 문자열이 정규표현식과 일치하는지 여부를 알아야할 때,   RegExp.exec(): 일치하는 것 중 제일 첫번째 것만 알고싶을 때, 캡처 그룹을 알고 싶고 전역 플래그가 셋팅되어 있을 때\n       2.3.15. String.prototype.matchAll() str.matchAll(regexp) // 정규표현식 // str이 regexp와 일치하면, 일치하는 전체 str을 첫번째 item으로 하고 이후 괄호 안 캡처 결과를 포함하는 arr 반환, 일치 항목이 없으면 null 반환    2.3.16. String.prototype.valueOf() str.valueOf() // str의 원시값 반환     2.4. 사용 금지 (웹 표준 아님) 2.4.1. String.prototype.anchor()  2.4.2. String.prototype.big()  2.4.3. String.prototype.blink()  2.4.4. String.prototype.bold()  2.4.5. String.prototype.fixed()  2.4.6. String.prototype.fontcolor()  2.4.7. String.prototype.fontsize()  2.4.8. String.prototype.italics()  2.4.9. String.prototype.link()  2.4.10. String.prototype.small()  2.4.11. String.prototype.strike()  2.4.12. String.prototype.sub()  2.4.13. String.prototype.substr()  2.4.14. String.prototype.sup()  2.4.15. String.prototype.toSource()     ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/d-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A9%94%EC%86%8C%EB%93%9C-object-methods/","summary":"본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. 문자열 프로퍼티 1.1. String.length str.length //\u0026gt; str의 문자 개수 반환      2. 문자열 메소드 2.1. 변환 2.1.1. String.prototype.concat() str.concat(\u0026#39;s1\u0026#39;, \u0026#39;s2\u0026#39;, ...\u0026#39;s\u0026#39;) //\u0026gt; str에 하나 이상의 \u0026#39;s\u0026#39;를 합쳐 새로운 str로 반환    2.1.2. String.prototype.slice() str.slice(start, end) //\u0026gt; start부터 end (옵션: 기본 str.","title":"자바스크립트 문법 - D - 문자열 주요 메소드 (String methods essential)"},{"content":" 본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. 객체 1.1. 주의사항 key를 숫자로 입력해도 string으로 자동 변환됩니다.\n    2. 객체 메소드 2.1. 직접 수정 원본 객체를 직접 수정하여 변경합니다.\n 2.1.1. Object.assign() Object.assign(obj, src1, src2, ...src) // src 를 obj 에 복사한 뒤 obj 반환 (원본 obj 변경), 동일한 속성은 더 뒤의 파라미터 객체에 의해 덮어쓰여짐.     2.2. 변환 원본 객체는 유지한채 내부 요소를 변환하여 반환합니다.\n 2.2.1. Object.keys() Object.keys(obj) // obj내 전체 key를 arr로 반환 // getOwnPropertyNames() 와 차이점: enumerable = true 만    2.2.2. Object.getOwnPropertyNames() Object.getOwnPropertyNames(obj) // obj내 전체 key를 arr로 반환 // enumerable = true/false 둘다 가능    2.2.3. Object.values() Object.values(obj) // obj의 전체 value를 arr로 반환    2.2.4. Object.prototype.toString() obj.key.toString() // arr의 모든 item을 쉼표 구분자로 합쳐 새로운 str로 반환    2.2.5. Object.entries() Object.entries(obj) //obj의 key와 value를 [key, value] 형태의 arr로 반환.   눌러서 예시 확인 Object.entries({a:1, b:2, c:3}) //\u0026gt; [[\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2], [\u0026#34;c\u0026#34;, 3]]      2.2.6. Object.fromEntries() Object.fromEntries(arr) // [key, value] 쌍의 arr을 obj로 반환   눌러서 예시 확인 Object.fromEntries([[\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2], [\u0026#34;c\u0026#34;, 3]]) //\u0026gt; {a:1, b:2, c:3}       2.3. 검색 및 확인 2.3.1. Object.prototype.hasOwnProperty() obj.hasOwnProperty(\u0026#39;key\u0026#39;) // obj의 key 존재 여부를 true/false 로 반환    2.3.2. Object.is() Object.is(H1, H2); // H1과 H2의 같음 여부를 true/false 로 반환     2.4. 기타 2.4.1. Object.prototype.toLocaleString() H.toLocaleString() // 숫자 및 숫자가 포함된 대상을 지역에 따른 표현을 적용한 문자열로 반환 (원본 H 유지)    2.4.2. Object.prototype.valueOf() obj.valueOf() // obj의 원시값 반환    2.4.3. Object.create() let obj = Object.create(prototype) // prototype을 갖는 obj 생성    2.4.4. Object.defineProperties() Object.defineProperties(obj, { key1: { value: undefined, writable: false, configurable: false, enumerable: false, get: undefined, set: undefined }, key2: { value: \u0026#39;value2\u0026#39;, }, key3: {} }); // obj에 1개 이상의 src와 그 속성 (옵션 - 기본: key1의 작성값) 을 정의    2.4.5. Object.defineProperty() Object.defineProperty(obj, \u0026#39;key\u0026#39;, { value: undefined, writable: false, configurable: false, enumerable: false, get: undefined, set: undefined }) // obj에 단일 src와 그 속성 (옵션 - 기본: key1의 작성값) 을 정의    2.4.6. Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor(obj, prop) // obj내 prop의 설명을 반환, 없으면 undefined 반환    2.4.7. Object.getOwnPropertyDescriptors() Object.getOwnPropertyDescriptors(obj) // obj내 전체 prop의 설명을 반환, 없으면 undefined 반환     2.5. 기타 눌러서 확인 Object.freeze() Object.freeze(obj) // obj를 변경 불가 상태로 만듦 (원본 obj 변경), 변경된 obj 반환   Object.preventExtensions() Object.preventExtensions(obj) // obj 를 확장 불가로 만듦 (원본 obj 변경), 변경된 obj 반환   Object.seal() Object.seal(obj) // obj를 밀봉(봉인) 상태로 만듦 (원본 obj 변경), 변경된 obj 반환   Object.setPrototypeOf() Object.setPrototypeOf(obj, prototype) // obj를 다른 prototype으로 변경 (원본 obj 변경), 변경된 obj 반환   Object.getOwnPropertySymbols() Object.getOwnPropertySymbols(obj) // obj내 전체 심볼을 배열로 반환   Object.prototype.propertyIsEnumerable() obj.propertyIsEnumerable(\u0026#39;prop\u0026#39;) // obj내 prop의 열거 가능 여부를 true/false 로 반환   Object.isExtensible() Object.isExtensible(obj) // obj의 확장 가능 여부를 true/false 로 반환   Object.isFrozen() Object.isFrozen(obj) // obj의 동결 여부를 true/false 로 반환   Object.isSealed() Object.isSealed(obj) // obj의 봉인 여부를 true/false 로 반환   Object.getPrototypeOf() Object.getPrototypeOf(obj) // obj의 프로토타입을 반환   Object.prototype.isPrototypeOf() Object.isPrototypeOf(obj) // 프로토타입 체인에 obj가 존재하는지 여부를 true/false 로 반환   눌러서 활용법 확인 /// instanceof 연산자와 함께 특정 프로토타입으로부터 상속된 객체만 작동 (특정 메소드나 속성이 객체에 있다는걸 보장) if (Fi.prototype.isPrototypeOf(obj)) { // do something safe }          3. 활용 3.1. 객체 추가 // Object.assign(obj, src1, src2, ...src) - 원본 obj 변경 const src = { a: 1 }; const add = Object.assign({}, src); console.log(add); //\u0026gt; { a: 1 }   // ... (펼침 연산자) - 원본 obj 유지 {...obj, k1: v1, k2: v2}   // ... (펼침 연산자) 로 깊은 복사 {...obj, k1: {...obj.k1}}      ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/c-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%86%8C%EB%93%9C-object-methods/","summary":"본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. 객체 1.1. 주의사항 key를 숫자로 입력해도 string으로 자동 변환됩니다.\n    2. 객체 메소드 2.1. 직접 수정 원본 객체를 직접 수정하여 변경합니다.\n 2.1.1. Object.assign() Object.assign(obj, src1, src2, ...src) // src 를 obj 에 복사한 뒤 obj 반환 (원본 obj 변경), 동일한 속성은 더 뒤의 파라미터 객체에 의해 덮어쓰여짐.","title":"자바스크립트 문법 - C - 객체 주요 메소드 (Object methods essential)"},{"content":" 본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. 배열 프로퍼티 1.1. Array.prototype.length arr.length // arr의 value 갯수 반환      2. 배열 메소드 2.1. 직접 수정 원본 배열을 직접 수정하여 변경합니다.\n 2.1.1. Array.prototype.shift() arr.shift() // arr의 첫 번째 요소를 제거 (원본 arr 변경), 제거된 요소를 반환    2.1.2. Array.prototype.unshift() arr.unshift(v) // v를 arr의 첫 value으로 추가 (원본 arr 변경), 새로운 길이를 반환    2.1.3. Array.prototype.pop() arr.pop() // arr의 마지막 value 을 제거 (원본 arr 변경), 제거한 value을 반환, 빈 arr은 undefined 반환    2.1.4. Array.prototype.push() arr.push(v1, v2, ...v) // arr의 끝에 하나 이상의 v 추가 (원본 arr 변경), arr의 새로운 길이를 반환. (원본 변경)   눌러서 추가 활용 방법 확인 /// 두 배열 합치기, concat()은 원본 유지 Array.prototype.push.apply(arr, arr1)      2.1.5. Array.prototype.splice() arr.splice(start, n, v1, v2, ...v) // start 부터 n개 (옵션 - 기본: end 까지) value 삭제 후 그 자리에 하나 이상의 v (옵션 - 기본: 없음) 추가 (원본 arr 변경), 제거한 value들로 구성된 arr 반환    2.1.6. Array.prototype.fill() arr.fill(v, start, end) // start (옵션 - 기본: 0) 에서 end (옵션 - 기본: arr.length) 까지 value을 v로 채움 (원본 arr 변경), 변경된 arr 반환    2.1.7. Array.prototype.copyWithin() arr.copyWithin(target, start, end) // arr의 start (옵션 - 기본: 0) 에서 end (옵션 - 기본: arr.length) 까지 value을 복사하여 target 부터 덮어씌움 (원본 arr 변경), 변경된 arr 반환    2.1.8. Array.prototype.sort() arr.sort((a , b) =\u0026gt; a - b) // 정렬 함수 기준으로 정렬 (원본 arr 변경), 변경된 arr 반환   /// 정렬 함수 (a, b) =\u0026gt; a - b // a - b 오름차순 : 1, 2, 3, a, b, c // b - a 내림차순 : c, b, a, 3, 2, 1 // (옵션 - 기본: 문자열 기준 유니코드)    2.1.9. Array.prototype.reverse() arr.reverse() // arr의 순서를 반전 (원본 arr 변경), 변경된 arr 반환    2.1.10. Array.prototype.flat() arr.flat(n) //고차 arr을 n (옵션 - 기본: 1) 만큼 차수 낮춤 (원본 arr 변경), 변경된 arr 반환   눌러서 예시 확인 /// 예시 arr.flat(1) // [1,[2]] -\u0026gt; [1,2] / [1,[2,[3]]] -\u0026gt; [1,2,[3]] arr.flat(2) // [1,[2,[3]]] -\u0026gt; [1,2,3]     눌러서 활용법 확인 /// 배열 구멍 제거 const arr = [1, 2, , 4, 5] arr.flat() //\u0026gt; [1, 2, 4, 5]       2.2. 변환 원본 배열은 유지한채 내부 요소를 변환하여 반환합니다.\n 2.2.1. Array.prototype.concat() arr.concat(h1, h2, ...h) // arr에 하나 이상의 h[arr, value] 를 합쳐 새로운 arr 반환    2.2.2. Array.prototype.join() arr.join(\u0026#39;a\u0026#39;) // arr의 모든 value을 사이에 \u0026#39;a\u0026#39; 구분자를 넣어 더해 새로운 str로 반환, value이 undefined 또는 null이면 빈 str로 반환   /// 문자열 분할 str.split(\u0026#39;a\u0026#39;, n) // str을 \u0026#39;a\u0026#39; 구분자 (옵션 - 기본: 구분자 없음) 로 n 개 (옵션 - 기본: str.length) 까지 분할해 새로운 arr로 반환    2.2.3. Array.prototype.slice() arr.slice(start, end) // start부터 end (옵션 - 기본: arr.length) 전까지 (end 미포함) value을 새로운 arr로 반환    2.2.4. Array.prototype.toString() arr.toString() // value들을 쉼표를 구분자로 합쳐 새로운 str로 반환   눌러서 예시 확인 const arr = [1,2,3,4,5] console.log(arr.toString()) //\u0026gt; 1,2,3,4,5      2.2.5. Array.prototype.forEach() arr.forEach(p =\u0026gt; p + 1) // start 부터 end 까지 연산 함수 적용, 중간 탈출 불가, undefine 반환 // undefine을 반환하기 때문에 메소드 체인의 제일 마지막에서 연산 함수를 통해 외부로 효과를 적용해야 할때 사용 (추가적인 변수 선언 없이 한번에 실행)    2.2.6. Array.prototype.map() arr.map(x =\u0026gt; x + 1) // arr의 value에 연산 함수를 차례로 적용, 새로운 arr 반환 // undefine을 반환하기 때문에 메소드 체인의 제일 마지막에서 연산 함수를 통해 외부로 효과를 적용해야 할때 사용 (추가적인 변수 선언 없이 한번에 실행)   눌러서 주의사항 확인 /// 두개 이상의 p를 받는 연산 함수를 적용 시 기대와 다른 결과값이 나오므로 주의 [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;].map(parseInt)      2.2.7. Array.prototype.flatMap() 눌러서 내용 확인 arr.flatMap(p =\u0026gt; p + 1) // arr.map(p =\u0026gt; p + 1).flat(1)   /// flat().map() 이 아님 console.log([1, 2, [3, 3]].flat().map(x =\u0026gt; x + 1)) ///\u0026gt; [2, 3, 4, 4] console.log([1, 2, [3, 3]].map(x =\u0026gt; x + 1).flat()) ///\u0026gt; [2, 3, \u0026#34;3,31\u0026#34;]      2.2.8. Array.prototype.reduce() arr.reduce((acc, cur) =\u0026gt; acc + cur) arr.reduce((acc, cur, inx, src) =\u0026gt; acc + cur, int) // arr의 각 value을 차례로 cur에 대입하고 리듀서 함수를 적용, 결과를 acc에 누적하여 반환   /// 리듀서 (reducer) 함수: int (옵션 - 기본: 0) 를 초기값으로 시작, arr의 각 value이 차례로 cur에 대입되어 연산 함수를 적용한 뒤 acc에 누적 저장하여 반환 // acc: accumulator, cur: currentValue, idx: currentIndex, src: sourceArray, int: initialValue   눌러서 주의사항 확인 각 항목이 모두 리듀서 함수를 거치게 하려면 int (초기값: initialValue) 을 입력해야함 초기값이 없으면, . 배열의 첫번째 요소 (0번 인덱스) 를 accumulator에 누적한 후 1번 인덱스부터 리듀서 함수를 거친다. (0번 인덱스 항목은 리듀서 함수를 거치지 않음) . 배열의 요소 값이 1개인데 초기값도 제공하지 않은 경우 or 초기값은 있지만 배열이 빈 배열인 경우에는 그 단독 값을 리듀서를 거치지 않고 바로 반환 . 배열이 비었는데 초기값도 없는 상태에서 reduce() 를 호출하면 TypeError 오류가 발생\n   눌러서 추가 예시 확인 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n    2.2.9. Array.prototype.reduceRight() 눌러서 내용 확인 arr.reduceRight((acc, cur) =\u0026gt; acc + cur) arr.reduceRight((acc, cur, inx, src) =\u0026gt; acc + cur, int) // reduce() 와 같으나 value을 역순으로 cur에 대입      2.2.10. Array.from() Array.from(H, p =\u0026gt; p + 1) // H (\u0026#39;a\u0026#39;, arr, array-like, iterable, (p1, p2, ...p)) 를 각 value에 연산 함수 (옵션 - 기본: p =\u0026gt; p) 적용, 새로운 arr 반환     2.3. 검색 \u0026amp; 확인 배열의 value 또는 배열 자체를 검색하고 확인합니다.\n 2.3.1. Array.prototype.every() arr.every(p =\u0026gt; p \u0026lt; 10) // 모든 value이 판별 함수를 만족하면 true, 불만족 value 발견 시 false, 빈 배열은 true 반환    2.3.2. Array.prototype.some() arr.some(p =\u0026gt; p \u0026gt; 10) // 판별 함수를 만족하는 value 발견 시 true, 모두 불만족하면 false 반환, 빈 배열은 false 반환    2.3.3. Array.prototype.filter() arr.filter(p =\u0026gt; p \u0026lt; 10) // 판별 함수를 만족하는 value을 모아 새로운 arr 반환    2.3.4. Array.prototype.find() arr.find(p =\u0026gt; p \u0026lt; 10) // 판별 함수를 만족하는 첫번째 value을 반환, 없으면 undefined 반환    2.3.5. Array.prototype.findIndex() arr.find(p =\u0026gt; p \u0026lt; 10) //판별 함수를 만족하는 첫번째 value의 index를 반환, 없으면 -1 반환    2.3.6. Array.prototype.includes() arr.includes(a) // arr의 value 중 a의 존재 여부 확인, 있으면 true 반환, 없으면 false 반환    2.3.7. Array.prototype.indexOf() arr.indexOf(v, n) // arr의 value 중 v의 존재 여부 확인, n 번째 (옵션 - 기본: 1) index를 반환, 없으면 -1 반환    2.3.8. Array.prototype.lastIndexOf() arr.lastIndexOf() // indexOf() 와 달리 마지막 index 반환, 없으면 -1 반환    2.3.9. Array.isArray() Array.isArray(a) // a가 배열인지 판별, true/false 반환     2.4. 기타 관련 항목 더보기 Array.prototype.keys() arr.keys() // arr의 index를 차례로 제공하는 새로운 iterator 반환   Array.prototype.values() arr.values() // arr의 value을 차례로 제공하는 새로운 iterator 반환   Array.prototype.entries() arr.entries() // [index, item] 을 차례로 제공하는 새로운 iterator 반환   Array.of() Array.of(v1, v2, ...v) // [v1, v2, ...v] 반환   Array.prototype.toLocaleString() H.toLocaleString() // 숫자 및 숫자가 포함된 대상을 지역에 따른 표현을 적용한 문자열로 반환 (원본 H 유지)   눌러서 예시 확인 const num = 12341.23 console.log(num.toLocaleString(\u0026#34;ko-KR\u0026#34;, { style: \u0026#39;currency\u0026#39;, currency: \u0026#39;KRW\u0026#39; })); //\u0026gt; ₩12,341       사용 금지 (웹 표준 아님)\n  Array.prototype.toSource()\n// 배열의 소스 코드 문자열을 반환              3. 활용 3.1. arr의 특정 v 제거 // arr.splice(start, n, v1, v2, ...v) - 원본 arr 변경 arr.splice(target, 1)   // arr.slice(start, end).concat(h1, h2, ...h) - 원본 arr 유지 arr.slice(0, target).concat(arr.slice(target + 1))    3.2. arr의 앞/뒤에 v 추가 // arr.unshift(v) / arr.push(v1, v2, ...v) - 원본 arr 변경 arr.unshift(v) arr.push(v)   // ... (펼침 연산자) - 원본 arr 유지 [v, ...arr] [...arr, v]    3.3. arr 정렬 // arr.sort((a , b) =\u0026gt; a - b ) - 원본 arr 변경 arr.sort((a , b) =\u0026gt; a - b )   // ... (펼침 연산자) - 원본 arr 유지 [...arr].sort((a , b) =\u0026gt; a - b )    3.4. 특정 item의 모든 index 찾기 //arr.indexOf(item, start) const result = []; const arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;]; const item = \u0026#39;a\u0026#39;; let idx = arr.indexOf(value); while (idx != -1) { result.push(idx); idx = arr.indexOf(value, idx + 1); } console.log(result); //\u0026gt; [0, 2, 4]    3.5. arr내 특정 value 존재 여부 확인 후 없으면 추가 //arr.indexOf(value, start) function update (arr, value) { if (arr.indexOf(value) === -1) { arr.push(value); console.log(\u0026#39;새로운 arr: \u0026#39; + arr); } else if (arr.indexOf(value) \u0026gt; -1) { console.log(value + \u0026#39; 은 이미 arr에 존재\u0026#39;); } } const arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; update(arr, \u0026#39;e\u0026#39;); //\u0026gt; 새로운 arr: a, b, c, d, e update(arr, \u0026#39;e\u0026#39;); //\u0026gt; e 은 이미 arr에 존재      ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/b-%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%86%8C%EB%93%9C-array-methods/","summary":"본 문서의 작성 규칙은 자바스크립트 문법 작성 규칙 을 참고하세요. 활용 빈도와 중요도가 높다고 생각되는 항목으로 본문을 구성하였습니다. 나머지 항목은 기타 챕터에서 확인 가능합니다.\n   1. 배열 프로퍼티 1.1. Array.prototype.length arr.length // arr의 value 갯수 반환      2. 배열 메소드 2.1. 직접 수정 원본 배열을 직접 수정하여 변경합니다.\n 2.1.1. Array.prototype.shift() arr.shift() // arr의 첫 번째 요소를 제거 (원본 arr 변경), 제거된 요소를 반환    2.","title":"자바스크립트 문법 - B - 배열 주요 메소드 (Array methods essential)"},{"content":"   표기법을 단순화시켜 실제 사용되는 형태로 표현했습니다. 그 과정에서 다소 생략 또는 비약이 있을 수 있습니다.\n  반환값, 기존 대상의 변경 여부, 항목의 생략 가능 여부 (+생략했을때 기본값) 을 명확히 하는데 중점을 뒀습니다.\n  학습 과정중, 정리를 위해 작성하여 오류가 있을 수 있습니다. 이에 대해 제 스스로 알게되거나, 관련 내용을 전달해 주시면 업데이트 하도록 하겠습니다.\n  오류 수정 외에도 관련 예시와 활용법 추가는 지속적으로 진행할 예정입니다.\n  본 문서의 첫번째 작성 목적은 제 학습에 대한 정리와 리마인드를 용이하게 하려는 것이나, 자바스크립트 학습을 시작하시는 분들에게는 파악이 필요한 대상의 요약본이, 숙련자분들에게는 리마인드에 도움이 되는 도구가 되었으면 하는 바램입니다.\n     1. 작성 규칙 요약 1.1. 요소       x1\n 시작 요소\n   …​x\n 마지막 요소\n   x\n 특정 요소 (요소 리스트중 1개 지칭)\n     1.2. 인덱스       start\n 시작 인덱스\n   end\n 끝 인덱스\n   target\n 특정 인덱스\n   차례로\n start → end\n   역순으로\n end → start\n       2. Array (배열) 2.1. 작성 규칙       Array\n arr = []\n   index\n i\n   value\n v\n     2.2. 예시 arr = [v1, v2, ...v] arr[i1] = v1      3. M x N Matrix (M x N 행렬) 3.1. 작성 규칙       행\n i (y 좌표)\n   열\n j (x 좌표)\n     3.2. 예시 matrix = [ [i1, j1], [i1, j2], [i1, ...j], [i2, j1], [i2, j2], [i2, ...j], [...i, j1], [...i, j2], [...i, ...j] ]      4. Object (객체) 4.1. 작성 규칙       Object\n obj = {}\n   key\n k\n   value\n v\n     4.2. 예시 obj = {k1: v1, k2: v2, ...k: ...v} obj.k1 = v1      5. String (문자열) 5.1. 작성 규칙       String\n str = \u0026#39;\u0026#39;\n   index\n i\n   string\n s\n     5.2. 예시 str = \u0026#39;s1s2...s\u0026#39; str[i1] = \u0026#39;s1\u0026#39;      6. Map (맵) 6.1. 작성 규칙       Map\n map = { =\u0026gt; }\n   key\n k\n   value\n v\n     6.2. 예시 map = {k1 =\u0026gt; v1, k2 =\u0026gt; v2, ...k =\u0026gt; ...v} map.set(k1, v1) map.get(k1) = v1      7. Set (셋) 7.1. 작성 규칙       Set\n set = {}\n   value\n v\n     7.2. 예시 set = {v1, v2, ...v}      8. Function (함수) 8.1. 작성 규칙       Function\n func = (){} func = () ⇒ {}\n   parameter\n p\n   연산 함수\n p ⇒ p + 1\n   판별 함수\n p ⇒ p \u0026lt; 10\n     8.2. 예시 func = (p1, p2, ...p) {p1, p2, ...p} func = (p1, p2, ...p) =\u0026gt; p1, p2, ...p      9. 기타       여러 형태 (hybrid) 가 가능한 요소\n H\n   0 포함 자연수\n n\n   음의 정수\n -n\n   무한대\t1e9 (10의 9승),\n Infinity\n   불리언\n true/false\n   생략 가능한 항목의 기본값이 0 인 경우\n 옵션 - 기본: 0\n      ","permalink":"https://cspidar.github.io/blog/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95/a-%EC%9E%91%EC%84%B1-%EA%B7%9C%EC%B9%99_%EC%9A%A9%EC%96%B4%EC%99%80-%EA%B0%9C%EB%85%90/","summary":"표기법을 단순화시켜 실제 사용되는 형태로 표현했습니다. 그 과정에서 다소 생략 또는 비약이 있을 수 있습니다.\n  반환값, 기존 대상의 변경 여부, 항목의 생략 가능 여부 (+생략했을때 기본값) 을 명확히 하는데 중점을 뒀습니다.\n  학습 과정중, 정리를 위해 작성하여 오류가 있을 수 있습니다. 이에 대해 제 스스로 알게되거나, 관련 내용을 전달해 주시면 업데이트 하도록 하겠습니다.\n  오류 수정 외에도 관련 예시와 활용법 추가는 지속적으로 진행할 예정입니다.","title":"자바스크립트 문법 - A - 작성 규칙, 용어와 개념 (Style, Terms and Concepts)"},{"content":" 1. 왜 github?   git: 소스코드를 관리하기 위한 버전 관리 시스템, 이력 관리와 협업과 관련된 다양한 기능을 제공\n  github: git 을 인터넷에 업로드하는 서비스, 이외에도 유사 서비스 (gitlab 등) 이 있음\n   git은 브랜치, 모듈, 로그 등 다양한 기능을 제공하여 개발환경에 훌륭하고 다양한 편의 기능을 제공 하지만, 복잡해보이는 수많은 개념 + 낯선 터미널 명령어때문에 진입 장벽이 다소 높다고 생각합니다. 따라서 Google Drive 나 Naver Cloud 와 같이, github를 코드 + 파일을 저장하는 클라우드 서비스처럼 활용하는 방법만 소개하면 도움이 될 것이라고 생각해 이번 포스트를 작성합니다.\n   2. 빠른 시작 2.1. 준비 2.1.1. (선택) IDE 설치 Visual studio code 눌러서 설치 방법과 기본 사용법 확인   Visual studio code 의 장점\n  오픈소스\n  유저수가 많아 다양한 확장 플러그인 사용 가능\n  프로그램 내에서 터미널 사용이 편리\n  최적화가 잘되어 있어 실행 \u0026amp; 반응속도 빠름\n  타 프로그램 (예: Atom) 에 비해 한글 입력이 안정적\n     사이트 주소: https://code.visualstudio.com/\n  설치 방법\n홈페이지  Download for Windows  실행\n   설치 옵션중 아래 표시된 두 옵션 (\u0026#34;Code로 열기\u0026#34;…​) 은 탐색기에서 폴더 상태로 바로 프로젝트를 열기 위해 체크한 상태로 설치하는 것을 추천합니다.\n     프로젝트 폴더 열기 프로젝트 폴더채로 열면 좌측에 프로젝트 트리구조가 바로 나타나고 터미널이 프로젝트 root 폴더 상태로 열려 편리합니다.\n프로젝트 폴더 우클릭  Code로 열기\n     터미널 열기/닫기 단축키\nCrtl+`\n              2.1.2. git 설치 https://git-scm.com/downloads\n 홈페이지  파일 다운  실행\n   별다른 설정 건드릴것 없이 Install 을 눌러서 설치하세요.\n    2.1.3. github 가입 https://github.com/\n 홈페이지  Sign Up\n    저장소 (Repository) 만들기   New 클릭\n    정보 입력 및 저장소 생성\n  ① Repository name: 저장소 이름. 참고로 저장소의 전체 주소는 https://github.com/사용자아이디/저장소이름.git 의 형태로 설정됩니다. ② Description: 저장소 설명. 필수 아님. ③ Public / Private: 저장소의 공개 / 비공개 여부를 선택. 편한대로 설정하세요. ④ 필수 아님. ⑤ Create repository: 저장소 생성. ①번 항목 \u0026#34;저장소 이름\u0026#34;만 적당히 써주고 바로 클릭해도 무방합니다.\n     저장소에 연결 방금 생성한 github의 저장소와 사용할 기기내 원하는 폴더를 서로 연결합니다.\n  원하는 폴더를 Visual studio code 를 통해 열고 터미널 창을 켜거나 기타 터미널 프로그램을 통해 여세요. Visual studio code 기본 설치 및 폴더 열기 방법은 2, “빠른 시작” 챕터 맨 처음 (선택) IDE 설치 방법 확인: Visual studio code 항목에서 확인 항목에서 확인할 수 있습니다.\n  원하는 폴더를 열었는지 확인하세요. (아래는 Github_test 폴더를 연 이미지 입니다.)\n    다음 명령어들을 입력하세요.\n git init: 폴더에 git을 사용할 수 있도록 준비합니다.\ngit init           \u0026#34;.git\u0026#34; 이라는 숨김 폴더가 프로젝트 폴더에 생성됩니다. 프로젝트의 git 관련 상태가 저장되어 있어서 해당 폴더를 지우면 git 관련 상태를 초기화할 수 있습니다.\n       만든 github 저장소의 \u0026#34;git remote add origin\u0026#34; 으로 시작하는 항목을 복사 후 터미널에 붙여넣어 입력하세요. 폴더를 2.1.3.2, “저장소 (Repository) 만들기” 에서 만든 github 저장소와 연결합니다.\ngit remote add origin https://github.com/-----/-----.git           아무런 메세지도 나오지 않는것이 정상적으로 입력된 상태입니다.\n            저장소에 업로드 하기 (push)  git add .: 폴더내 전체 파일을 업로드 대상에 추가합니다.\n    git commit -m \u0026#39;커밋 메세지\u0026#39;: 이번 업로드에 대한 설명 작성할 수 있습니다.\n    git push origin main: 업로드를 실행합니다.\n  git add . git commit -m \u0026#39;first commit\u0026#39; git push origin main       지금 (github를 웹하드처럼 사용하려는) 은 add, commit, push를 연속된 과정이라고 생각하세요. 많은것을 빠뜨리고 이야기하지만, 심화 내용은 더 잘 설명되어있는 자료가 많으니 참고하시면 좋을듯 합니다.\n         커밋 메세지는 github에 파일 및 코드가 업로드 되었을때를 구분하는 역할을 하며 아무 메세지나 입력해도 되지만, 보통은 이번에 올릴 코드나 파일에 대한 짧은 설명을 입력합니다.\n         저장소에 업로드된 파일 확인 github 저장소 페이지에 가보면 정상적으로 업로드 되었음을 확인할 수 있습니다.\n       git은 버전 및 이력관리를 위한 툴인 만큼, 내용이 수정된 같은 이름을 가진 파일이라도 수정 내용만 새로 업데이트 하며 이전의 상태로 보존하여 이후에 추적이 가능합니다.\n      다른 작업 환경에서 저장소 내용을 복사 (clone) 하기  2.1.3.3, “저장소에 연결” 챕터의 첫번째 과정과 같이, 원하는 폴더를 Visual studio code 를 통해 열고 터미널 창을 켜거나, 기타 터미널 프로그램을 통해 여세요.\n  git clone \u0026#34;저장소 주소\u0026#34;.git 을 입력하면 해당 폴더내 저장소 이름 폴더 안에 해당 저장소가 복사됩니다.\ngit clone https://github.com/-----/-----.git           기존 작업 환경에서 최신 저장소 내용을 끌어 (pull) 오기  2.1.3.3, “저장소에 연결” 챕터의 첫번째 과정과 같이, 원하는 폴더를 Visual studio code 를 통해 열고 터미널 창을 켜거나, 기타 터미널 프로그램을 통해 여세요.\n  git pull \u0026#34;저장소 주소\u0026#34;.git 을 입력하면 해당 폴더내 저장소 이름 폴더 안에 해당 저장소가 복사됩니다.\ngit clone https://github.com/-----/-----.git           ","permalink":"https://cspidar.github.io/blog/posts/%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0/%EC%BD%94%EB%93%9C-%EC%A0%80%EC%9E%A5%EC%86%8C-github-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95/","summary":"1. 왜 github?   git: 소스코드를 관리하기 위한 버전 관리 시스템, 이력 관리와 협업과 관련된 다양한 기능을 제공\n  github: git 을 인터넷에 업로드하는 서비스, 이외에도 유사 서비스 (gitlab 등) 이 있음\n   git은 브랜치, 모듈, 로그 등 다양한 기능을 제공하여 개발환경에 훌륭하고 다양한 편의 기능을 제공 하지만, 복잡해보이는 수많은 개념 + 낯선 터미널 명령어때문에 진입 장벽이 다소 높다고 생각합니다. 따라서 Google Drive 나 Naver Cloud 와 같이, github를 코드 + 파일을 저장하는 클라우드 서비스처럼 활용하는 방법만 소개하면 도움이 될 것이라고 생각해 이번 포스트를 작성합니다.","title":"코드 저장소 github - 기본 사용법 (Windows10)"},{"content":" 화면을 녹화하여 만든 움직이는 이미지로 문서의 가독성을 개선\n 1. 왜 ScreenToGif? https://www.screentogif.com/\n 오픈소스: 광고, 워터마크, 분량제한 없이 사용 가능 다양한 기능 및 설정: 녹화 범위 지정, 마우스 위치 강조, 클릭 효과, 고정창 마우스 따라다니기 기능, gif, avi 등 다양한 출력 방식 제공 등\n 비교 대상 확인   CamStudio 오픈소스. 마우스 위치 강조나 클릭 효과 있음. 출력 양식 부족, 부가 기능 부족 소개 사이트에서의 인터페이스는 처참하지만.. 실제 윈도우10 환경에서 사용해보면 봐줄만 하다. 윈도우 기본 인터페이스를 사용해서 그런듯.\n 웹 검색 이미지   설치 후 실행 화면 (Windows10)    ShareX https://getsharex.com/ 오픈소스. 추천 사이트에서 핫함, 자체 서비스에 쉽게 업로드하는것에 집중된 느낌? 영역 설정 기능이 없다. 녹화 관련 설정은 이게 전부.\n ShareX 화면 녹화 설정 항목  화면 영상 녹화보다는 이미지 캡처 및 편집에 집중한 느낌, 하지만 이미지 캡처 관련해서는 다양한 양식을 지원하고 문서도 훌륭하게 구성되어 있다.\n   https://getsharex.com/image-effects/    Free Cam https://www.freescreenrecording.com 무료 인듯 하면서 유료.\n 무료 - 유료 기능 차이     이외의 프로그램도 이후에 테스트해보고 더좋으면 메인 소개글을 교체, 아니면 여기 리스트에 추가할 예정\n   내가 필요로 한 + ScreenToGif에서 만족하는 기능 리스트 확인   캡처 영역 설정 기능\n  마우스 커서 강조, 클릭 표시 기능 → 마우스 따라다니기 기능\n  녹화 시작 중지 단축키\n  무료이면서 광고 워터마크 분량제한이 없을것\n  결과물에 대한 자유로운 사용 가능\n  등등\n   여러 이유가 있겠지만 현재로써는 가장 나은 프로그램이라고 판단 나중에 더 좋은 툴을 알게된다면 업데이트 예정\n     2. 빠른 시작 2.1. 설치 https://camstudio.org/\n    2.2. 설정 2.2.1. 프로그램 설정 https://www.screentogif.com/features 홈페이지에 모든 설정 항목들이 설명되어 있지는 않은것으로 보임\n   프로그램 설정창 들어가기\n    사용 추천 설정\n    기본 설정값에서 변경한 부분: \u0026#39;마우스 따라다니기 기능\u0026#39; 활성화 + 녹화 경계 관련 수치 \u0026#39;40\u0026#39; 설정\n        확인 을 누르면 아래와 같이 알림창 팝업\n  다시 한번 아래의 확인 을 누르면 단축키 설정창이 팝업된다.\n   F6 설정\n      2.2.2. 녹화 설정   녹화 모드 들어가기\n    사용 추천 설정\n    마우스 따라다니기 모드 표시: 마우스 따라다니기 모드 켯을때 아이콘 표시\n  창맞춤: 해당 아이콘을 드래그하여 창맞춤 기능 활성화\n  프로그램 설정창 열기: 2.2.1, “프로그램 설정” 의 설정창 열기\n  녹화 프레임 설정: 1-60 까지 최대 초당 프레임 수 설정, 뒤에서 이야기하겠지만 60프레임으로 해도 자체 인코딩 성능이 꽤 훌륭하여 용량은 생각보다 그리 크지 않음.\n  녹화 창 크기 수동 입력: 녹화 모드 창의 크기를 직접 픽셀 단위로 입력 가능\n  녹화 버튼: 녹화 시작 버튼 (기본 단축키: F7, 종료 단축키: F8 )\n           2.3. 녹화 편집 녹화를 종료하면 (기본 단축키: F8) 자동으로 아래와 같이 결과 파일 편집기 창이 팝업\n   편집기\n    결과 편집\n화면 하단에서 원하는 프레임을 선택하여 잘라내거나 전환 효과 (페이드 아웃, 넘기기) 를 적용하는 정도 편집이 가능\n   인코딩 및 저장 상단 리본 메뉴 › 파일 › 저장 를 누르면 파일로 저장하기 위한 인코딩 옵션 메뉴가 화면 좌측에 열림 파일 종류, 인코더, GIF 설정, 파일 경로, 파일명 등 설정 가능\n  하단 파일 탭에 저장 경로를 설정한 뒤 저장 버튼 또는 단축키 ALT+E / ENTER 를 입력하면 인코딩이 시작된다.\n          2.4. 사용  촬영 결과  해상도: 720P, 시간: 20초 기준 약 6 MB 정도 용량\n    ","permalink":"https://cspidar.github.io/blog/posts/%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0/%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%99%94%EB%A9%B4-%EB%85%B9%ED%99%94/","summary":"화면을 녹화하여 만든 움직이는 이미지로 문서의 가독성을 개선\n 1. 왜 ScreenToGif? https://www.screentogif.com/\n 오픈소스: 광고, 워터마크, 분량제한 없이 사용 가능 다양한 기능 및 설정: 녹화 범위 지정, 마우스 위치 강조, 클릭 효과, 고정창 마우스 따라다니기 기능, gif, avi 등 다양한 출력 방식 제공 등\n 비교 대상 확인   CamStudio 오픈소스. 마우스 위치 강조나 클릭 효과 있음. 출력 양식 부족, 부가 기능 부족 소개 사이트에서의 인터페이스는 처참하지만.. 실제 윈도우10 환경에서 사용해보면 봐줄만 하다.","title":"움직이는 이미지 만들기 - 화면 녹화: ScreenToGif"}]